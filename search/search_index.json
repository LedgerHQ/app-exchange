{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Ledger Swap documentation","text":"<p>This documentation is designed to help you understand how the Ledger Swap feature works and to guide you through modifying your coin application to be compatible with it.</p> <p>The Swap feature enables users to securely exchange one cryptocurrency for another directly from their Ledger device, within Ledger Wallet. It uses a trusted, multi-step process to facilitate communication between Ledger Wallet, the Trade Partner, the Exchange application, and the respective Coin applications on the device.</p> <p>Built with robust security at every stage, the process includes cryptographic validation and transaction signatures. Final confirmation is conducted directly on the device screen, ensuring that only validated transactions are signed and authorized.</p>"},{"location":"#key-components-of-the-swap-flow","title":"Key Components of the Swap Flow","text":"<p>The Swap process involves the following actors:</p> <ul> <li>The Trade Partner: Proposes a trade offer to the Ledger Wallet user, which must be clearly displayed on the device screen by the Exchange application.</li> <li>The Ledger Wallet: initiates and manages the transaction flow between the Partner and the Exchange application.</li> <li>The Exchange Application: serves as the intermediary between the Ledger Wallet, the involved coin applications, and the user.</li> <li>The Coin Applications: Handle the processing for both the FROM and TO currencies involved in the swap.</li> <li>The Ledger Crypto Asset List (CAL): Contains HSM-signed data of all SWAP-compatible currencies that help the Exchange application display the transaction proposal content on screen. </li> </ul> <pre><code>---\ntitle: Swap FROM currency -&gt; TO currency actors\n---\nflowchart LR\n    classDef invisible width:0px,height:0px,stroke-width:0px,fill:transparent;\n\n    subgraph P[TRADE PARTNER]\n        PAR@{ shape: rounded, label: \"Trade partner\" }\n    end\n\n    subgraph HSM[LEDGER HSM]\n        CAL@{ shape: rounded, label: \"Crypto&lt;br&gt;Asset List\" }\n    end\n\n    subgraph LL[LEDGER LIVE]\n        LLC@{ shape: rounded, label: \"Ledger Wallet\" }\n        %% Fake node to force the Partner -&gt; Exchange line to go through the LL box\n        FAKE((\" \")):::invisible\n    end\n\n    subgraph D[DEVICE]\n        EX@{ shape: rounded, label: \"Exchange&lt;br&gt;application\" }\n        FROM@{ shape: rounded, label: \"FROM&lt;br&gt;Coin application\" }\n        TO@{ shape: rounded, label: \"TO&lt;br&gt;Coin application\" }\n        SCREEN@{ shape: rounded, label: \"Device screen\" }\n    end\n\n    PAR &lt;-- \"&lt;div style='background:transparent;'&gt;Trade&lt;br&gt;establishment\" --&gt;LLC\n    PAR -- \"&lt;div style='background:transparent;'&gt;Signed transaction&lt;br&gt;proposal\" ---FAKE\n\n    CAL -- \"&lt;div style='background:transparent;'&gt;Coin&lt;br&gt;configurations\" --- FAKE\n\n    LLC &lt;-- \"&lt;div style='background:transparent;'&gt;Final payment request&lt;br&gt;/&lt;br&gt;Signature or refusal\" --&gt;FROM\n    LLC &lt;-- \"&lt;div style='background:transparent;'&gt;APDUs&lt;br&gt;/&lt;br&gt;RAPDUs\" --&gt;EX\n\n    EX &lt;-- \"&lt;div style='background:transparent;'&gt;Format amount&lt;br&gt;Address check\" --&gt;TO\n    EX &lt;-- \"&lt;div style='background:transparent;'&gt;Format amount&lt;br&gt;Address check&lt;br&gt;Final transaction details\" --&gt;FROM\n    FAKE --&gt;EX\n    EX &lt;-- \"&lt;div style='background:transparent;'&gt;User review\" --&gt;SCREEN</code></pre>"},{"location":"how_to_build_the_documentation/","title":"How to build the documentation portal locally","text":"<p>This document is intended at developers or reviewers of the documentation, it is not included in the documentation portal itself.</p>"},{"location":"how_to_build_the_documentation/#install-python-dependencies","title":"Install python dependencies","text":"<pre><code>pip install -Ur docs/requirements.txt\n</code></pre>"},{"location":"how_to_build_the_documentation/#clone-dependencies-repositories","title":"Clone dependencies repositories","text":"<pre><code>python docs/clone_dependencies.py\n</code></pre>"},{"location":"how_to_build_the_documentation/#run-the-documentation-builder-server","title":"Run the documentation builder server","text":"<pre><code># Run in the main exchange repository\nmkdocs serve\n</code></pre>"},{"location":"how_to_build_the_documentation/#access-the-local-documentation-portal","title":"Access the local documentation portal","text":"<pre><code>firefox http://127.0.0.1:8000/ &amp;\n</code></pre>"},{"location":"deps/app-boilerplate/","title":"Index","text":""},{"location":"deps/app-boilerplate/#ledger-boilerplate-application","title":"Ledger Boilerplate Application","text":"<p>This is a boilerplate application which can be forked to start a new project for the Ledger devices.</p>"},{"location":"deps/app-boilerplate/#quick-start-guide","title":"Quick start guide","text":""},{"location":"deps/app-boilerplate/#with-vscode","title":"With VSCode","text":"<p>You can quickly setup a convenient environment to build and test your application by using Ledger's VSCode developer tools extension which leverages the ledger-app-dev-tools docker image.</p> <p>It will allow you, whether you are developing on macOS, Windows or Linux to quickly build your apps, test them on Speculos and load them on any supported device.</p> <ul> <li>Install and run Docker.</li> <li>Make sure you have an X11 server running :</li> <li>On Ubuntu Linux, it should be running by default.</li> <li>On macOS, install and launch XQuartz     (make sure to go to XQuartz &gt; Preferences &gt; Security and check \"Allow client connections\").</li> <li>On Windows, install and launch VcXsrv     (make sure to configure it to disable access control).</li> <li>Install VScode and add Ledger's extension.</li> <li>Open a terminal and clone <code>app-boilerplate</code> with <code>git clone git@github.com:LedgerHQ/app-boilerplate.git</code>.</li> <li>Open the <code>app-boilerplate</code> folder with VSCode.</li> <li>Use Ledger extension's sidebar menu or open the tasks menu with <code>ctrl + shift + b</code>   (<code>command + shift + b</code> on a Mac) to conveniently execute actions :</li> <li>Build the app for the device model of your choice with <code>Build</code>.</li> <li>Test your binary on Speculos with <code>Run with Speculos</code>.</li> <li>You can also run functional tests, load the app on a physical device, and more.</li> </ul> <p>:information_source: The terminal tab of VSCode will show you what commands the extension runs behind the scene.</p>"},{"location":"deps/app-boilerplate/#with-a-terminal","title":"With a terminal","text":"<p>The ledger-app-dev-tools docker image contains all the required tools and libraries to build, test and load an application.</p> <p>You can download it from the ghcr.io docker repository:</p> <pre><code>sudo docker pull ghcr.io/ledgerhq/ledger-app-builder/ledger-app-dev-tools:latest\n</code></pre> <p>You can then enter this development environment by executing the following command from the directory of the application <code>git</code> repository:</p>"},{"location":"deps/app-boilerplate/#linux-ubuntu","title":"Linux (Ubuntu)","text":"<pre><code>sudo docker run --rm -ti --user \"$(id -u):$(id -g)\" --privileged -v \"/dev/bus/usb:/dev/bus/usb\" -v \"$(realpath .):/app\" ghcr.io/ledgerhq/ledger-app-builder/ledger-app-dev-tools:latest\n</code></pre>"},{"location":"deps/app-boilerplate/#macos","title":"macOS","text":"<pre><code>sudo docker run  --rm -ti --user \"$(id -u):$(id -g)\" --privileged -v \"$(pwd -P):/app\" ghcr.io/ledgerhq/ledger-app-builder/ledger-app-dev-tools:latest\n</code></pre>"},{"location":"deps/app-boilerplate/#windows-with-powershell","title":"Windows (with PowerShell)","text":"<pre><code>docker run --rm -ti --privileged -v \"$(Get-Location):/app\" ghcr.io/ledgerhq/ledger-app-builder/ledger-app-dev-tools:latest\n</code></pre> <p>The application's code will be available from inside the docker container, you can proceed to the following compilation steps to build your app.</p>"},{"location":"deps/app-boilerplate/#compilation-and-load","title":"Compilation and load","text":"<p>To easily setup a development environment for compilation and loading on a physical device, you can use the VSCode integration whether you are on Linux, macOS or Windows.</p> <p>If you prefer using a terminal to perform the steps manually, you can use the guide below.</p>"},{"location":"deps/app-boilerplate/#compilation","title":"Compilation","text":"<p>Setup a compilation environment by following the shell with docker approach.</p> <p>From inside the container, use the following command to build the app :</p> <pre><code>make DEBUG=1  # compile optionally with PRINTF\n</code></pre> <p>You can choose which device to compile and load for by setting the <code>BOLOS_SDK</code> environment variable to the following values :</p> <ul> <li><code>BOLOS_SDK=$NANOX_SDK</code></li> <li><code>BOLOS_SDK=$NANOSP_SDK</code></li> <li><code>BOLOS_SDK=$STAX_SDK</code></li> <li><code>BOLOS_SDK=$FLEX_SDK</code></li> <li><code>BOLOS_SDK=$APEX_SDK</code></li> </ul> <p>By default this variable is set to build/load for Nano S+.</p>"},{"location":"deps/app-boilerplate/#loading-on-a-physical-device","title":"Loading on a physical device","text":"<p>This step will vary slightly depending on your platform.</p> <p>:information_source: Your physical device must be connected, unlocked and the screen showing the dashboard (not inside an application).</p>"},{"location":"deps/app-boilerplate/#linux-ubuntu_1","title":"Linux (Ubuntu)","text":"<p>First make sure you have the proper udev rules added on your host :</p> <pre><code># Run these commands on your host, from the app's source folder.\nsudo cp .vscode/20-ledger.ledgerblue.rules /etc/udev/rules.d/\nsudo udevadm control --reload-rules\nsudo udevadm trigger\n</code></pre> <p>Then once you have opened a terminal in the <code>app-builder</code> image and built the app for the device you want, run the following command :</p> <pre><code># Run this command from the app-builder container terminal.\nmake load    # load the app on a Nano S+ by default\n</code></pre> <p>Setting the BOLOS_SDK environment variable will allow you to load on whichever supported device you want.</p>"},{"location":"deps/app-boilerplate/#macos-windows-with-powershell","title":"macOS / Windows (with PowerShell)","text":"<p>:information_source: It is assumed you have Python installed on your computer.</p> <p>Run these commands on your host from the app's source folder once you have built the app for the device you want :</p> <pre><code># Install Python virtualenv\npython3 -m pip install virtualenv\n# Create the 'ledger' virtualenv\npython3 -m virtualenv ledger\n</code></pre> <p>Enter the Python virtual environment</p> <ul> <li>macOS : <code>source ledger/bin/activate</code></li> <li>Windows : <code>.\\ledger\\Scripts\\Activate.ps1</code></li> </ul> <pre><code># Install Ledgerblue (tool to load the app)\npython3 -m pip install ledgerblue\n# Load the app.\npython3 -m ledgerblue.runScript --scp --fileName bin/app.apdu --elfFile bin/app.elf\n</code></pre>"},{"location":"deps/app-boilerplate/#test","title":"Test","text":"<p>The boilerplate app comes with functional tests implemented with Ledger's Ragger test framework.</p>"},{"location":"deps/app-boilerplate/#macos-windows","title":"macOS / Windows","text":"<p>To test your app on macOS or Windows, it is recommended to use Ledger's VS Code extension to quickly setup a working test environment.</p> <p>You can use the following sequence of tasks and commands (all accessible in the extension sidebar menu) :</p> <ul> <li><code>Select build target</code></li> <li><code>Build app</code></li> </ul> <p>Then you can choose to execute the functional tests :</p> <ul> <li>Use <code>Run tests</code>.</li> </ul> <p>Or simply run the app on the Speculos emulator :</p> <ul> <li><code>Run with Speculos</code>.</li> </ul>"},{"location":"deps/app-boilerplate/#linux-ubuntu_2","title":"Linux (Ubuntu)","text":"<p>On Linux, you can use Ledger's VS Code extension to run the tests. If you prefer not to, open a terminal and follow the steps below.</p> <p>Install the tests requirements :</p> <pre><code>pip install -r tests/standalone/requirements.txt\n</code></pre> <p>Then you can :</p> <p>Run the functional tests (here for nanos+ but available for any device once you have built the binaries) :</p> <pre><code>pytest tests/standalone/ --tb=short -v --device nanosp\n</code></pre> <p>Or run your app directly with Speculos</p> <pre><code>speculos --model nanosp build/nanos2/bin/app.elf\n</code></pre> <p>Please refer to the tests <code>README.md</code> for information on this topic.</p>"},{"location":"deps/app-boilerplate/#documentation","title":"Documentation","text":"<p>High level documentation such as application specification, APDU and transaction serialization are included in developer documentation which can be generated with doxygen</p> <pre><code>doxygen .doxygen/Doxyfile\n</code></pre> <p>the process outputs HTML and LaTeX documentations in <code>doc/html</code> and <code>doc/latex</code> folders.</p>"},{"location":"deps/app-boilerplate/#continuous-integration","title":"Continuous Integration","text":"<p>The flow processed in GitHub Actions is the following:</p> <ul> <li>Ledger guidelines enforcer which verifies that an app is compliant with Ledger guidelines.   The successful completion of this reusable workflow is a mandatory step for an app   to be available on the Ledger application store. More information on the guidelines can be found   in the repository ledger-app-workflow</li> <li>Code formatting with clang-format</li> <li>Compilation of the application for all Ledger hardware in ledger-app-builder</li> <li>Unit tests of C functions with cmocka (see unit-tests/)</li> <li>End-to-end tests with Speculos emulator   and ragger (see tests/)</li> <li>Code coverage with gcov/lcov   and upload to codecov.io</li> <li>Documentation generation with doxygen</li> </ul> <p>It outputs 3 artifacts:</p> <ul> <li><code>compiled_app_binaries</code> within binary files of the build process for each device</li> <li><code>code-coverage</code> within HTML details of code coverage</li> <li><code>documentation</code> within HTML auto-generated documentation</li> </ul>"},{"location":"deps/app-boilerplate/#are-you-developing-an-application-for-ledger-devices","title":"Are you developing an application for Ledger devices?","text":"<p>If so, This boilerplate will help you get started.</p> <p>For a smooth and quick integration:</p> <ul> <li>See the developers\u2019 documentation on the Developer Portal, and</li> <li>Go on Discord to chat with developer support and the developer community.</li> </ul>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/","title":"Technical Specification","text":"<p>Warning This documentation is a template and shall be updated with your own APDUs.</p>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#about","title":"About","text":"<p>This documentation describes the APDU messages interface to communicate with the Boilerplate application.</p> <p>The application covers the following functionalities :</p> <ul> <li>Get a public Boilerplate address given a BIP 32 path</li> <li>Sign a basic Boilerplate transaction given a BIP 32 path and raw transaction</li> <li>Sign a token transaction given a BIP 32 path, token address, and raw transaction</li> <li>Provide dynamic token metadata via CAL (Crypto Asset List) signed descriptors</li> <li>Retrieve the Boilerplate app version</li> <li>Retrieve the Boilerplate app name</li> </ul> <p>The application interface can be accessed over HID or BLE</p>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#apdus","title":"APDUs","text":""},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#get-boilerplate-public-address","title":"GET BOILERPLATE PUBLIC ADDRESS","text":""},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#description","title":"Description","text":"<p>This command returns the public key for the given BIP 32 path.</p> <p>The address can be optionally checked on the device before being returned.</p>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#coding","title":"Coding","text":""},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#command","title":"<code>Command</code>","text":"CLA INS P1 P2 Lc Le E0 05 00 : return address 00 variable variable 01 : display address and confirm before returning"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#input-data","title":"<code>Input data</code>","text":"Description Length Number of BIP 32 derivations to perform (max 10 levels) 1 First derivation index (big endian) 4 ... 4 Last derivation index (big endian) 4"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#output-data","title":"<code>Output data</code>","text":"Description Length Public Key length 1 Public Key var Chain code length 1 Chain code var"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#sign-boilerplate-transaction","title":"SIGN BOILERPLATE TRANSACTION","text":""},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#description_1","title":"Description","text":"<p>This command signs a Boilerplate transaction after having the user validate the transactions parameters.</p> <p>The input data is the RLP encoded transaction streamed to the device in 255 bytes maximum data chunks.</p>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#coding_1","title":"Coding","text":""},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#command_1","title":"<code>Command</code>","text":"CLA INS P1 P2 Lc Le E0 06 Chunk index More chunks variable variable <p>P1 - Chunk index:</p> <ul> <li><code>0x00</code>: First chunk (contains BIP32 path)</li> <li><code>0x01</code>: Second chunk</li> <li><code>0x02</code>: Third chunk</li> <li>...</li> <li><code>0xFF</code>: Maximum chunk index</li> </ul> <p>P2 - More chunks flag:</p> <ul> <li><code>0x00</code>: Last chunk (no more data)</li> <li><code>0x80</code>: More chunks to follow</li> </ul>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#examples","title":"<code>Examples</code>","text":""},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#example-1-single-apdu-small-transaction","title":"Example 1: Single APDU (small transaction)","text":"<p>When the entire transaction (including BIP32 path) fits in one APDU:</p> <pre><code>P1:   00  (first chunk)\nP2:   00  (last chunk, no more data)\n</code></pre>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#example-2-three-apdus-large-transaction","title":"Example 2: Three APDUs (large transaction)","text":"<p>When transaction data requires chunking across multiple APDUs:</p> <p>First APDU (P1=0x00, P2=0x80): Second APDU (P1=0x01, P2=0x80): Third APDU (P1=0x02, P2=0x00):</p>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#input-data-first-transaction-data-block","title":"<code>Input data (first transaction data block)</code>","text":"Description Length Number of BIP 32 derivations to perform (max 10 levels) 1 First derivation index (big endian) 4 ... 4 Last derivation index (big endian) 4"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#input-data-other-transaction-data-block","title":"<code>Input data (other transaction data block)</code>","text":"Description Length Transaction chunk variable"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#output-data_1","title":"<code>Output data</code>","text":"Description Length Signature length 1 Signature variable v 1"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#sign-boilerplate-token-transaction","title":"SIGN BOILERPLATE TOKEN TRANSACTION","text":""},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#description_2","title":"Description","text":"<p>This command signs a mock token transaction after user on-screen validation.</p> <p>The application will only display and sign transaction for tokens it has knowledge about (address/ticker/magnitude). Information is fetched from the internal hardcoded token database, or received from the PROVIDE_TOKEN_INFO API.</p> <p>The tokens and the token transaction format are made up for showcase purposes.</p>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#coding_2","title":"Coding","text":""},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#command_2","title":"<code>Command</code>","text":"CLA INS P1 P2 Lc Le E0 07 Chunk index More chunks variable variable <p>P1 - Chunk index:</p> <ul> <li><code>0x00</code>: First chunk (contains BIP32 path)</li> <li><code>0x01</code>: Second chunk</li> <li><code>0x02</code>: Third chunk</li> <li>...</li> <li><code>0xFF</code>: Maximum chunk index</li> </ul> <p>P2 - More chunks flag:</p> <ul> <li><code>0x00</code>: Last chunk (no more data)</li> <li><code>0x80</code>: More chunks to follow</li> </ul>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#examples_1","title":"<code>Examples</code>","text":""},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#example-1-single-apdu-small-transaction_1","title":"Example 1: Single APDU (small transaction)","text":"<p>When the entire transaction (including BIP32 path) fits in one APDU:</p> <pre><code>P1:   00  (first chunk)\nP2:   00  (last chunk, no more data)\n</code></pre>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#example-2-three-apdus-large-transaction_1","title":"Example 2: Three APDUs (large transaction)","text":"<p>When transaction data requires chunking across multiple APDUs:</p> <p>First APDU (P1=0x00, P2=0x80): Second APDU (P1=0x01, P2=0x80): Third APDU (P1=0x02, P2=0x00):</p>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#input-data-first-transaction-data-block_1","title":"<code>Input data (first transaction data block)</code>","text":"Description Length Number of BIP 32 derivations to perform (max 10 levels) 1 First derivation index (big endian) 4 ... 4 Last derivation index (big endian) 4"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#input-data-other-transaction-data-block_1","title":"<code>Input data (other transaction data block)</code>","text":"Description Length Token transaction chunk (includes 32-byte token address) variable"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#transaction-format","title":"<code>Transaction format</code>","text":"<p>The token transaction has the following format:</p> <ul> <li>Nonce (8 bytes, big endian)</li> <li>To address (20 bytes)</li> <li>Token address (32 bytes) - must be in the token database</li> <li>Amount (8 bytes, big endian) - in token's smallest unit</li> <li>Memo length (varint)</li> <li>Memo (variable length)</li> </ul>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#output-data_2","title":"<code>Output data</code>","text":"Description Length Signature length 1 Signature variable v 1"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#get-app-version","title":"GET APP VERSION","text":""},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#description_3","title":"Description","text":"<p>This command returns boilerplate application version</p>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#coding_3","title":"Coding","text":""},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#command_3","title":"<code>Command</code>","text":"CLA INS P1 P2 Lc Le E0 03 00 00 00 04"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#input-data_1","title":"<code>Input data</code>","text":"<p>None</p>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#output-data_3","title":"<code>Output data</code>","text":"Description Length Application major version 01 Application minor version 01 Application patch version 01"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#get-app-name","title":"GET APP NAME","text":""},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#description_4","title":"Description","text":"<p>This command returns boilerplate application name</p>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#coding_4","title":"Coding","text":""},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#command_4","title":"<code>Command</code>","text":"CLA INS P1 P2 Lc Le E0 04 00 00 00 04"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#input-data_2","title":"<code>Input data</code>","text":"<p>None</p>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#output-data_4","title":"<code>Output data</code>","text":"Description Length Application name variable"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#provide-token-info","title":"PROVIDE TOKEN INFO","text":""},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#description_5","title":"Description","text":"<p>This command provides dynamic token metadata to the device via a CAL (Crypto Asset List) signed descriptor. The descriptor is a TLV-encoded message signed by the CAL (a Ledger HSM) and the signature is validated using the device's PKI certificate infrastructure.</p> <p>Once provided, the dynamic token information takes priority over the hardcoded token database for subsequent token transaction signing. The token metadata persists in RAM across commands (including regular transactions) until the app exits or a new token is provided.</p> <p>This enables tokens to be added without firmware updates.</p> <p>IMPORTANT FOR THIRD-PARTY DEVELOPERS:</p> <ul> <li>For this feature to work on a given application, the CAL needs to maintain the knowledge   of the relevant tokens. This feature thus requires coordination with Ledger teams   before implementation. Please reach out before implementing it.</li> <li>The hardcoded token database is a simpler token management method as it only involves the application.</li> </ul> <p>Security model</p> <ul> <li>The CAL key must first be whitelisted with correct permissions on the device PKI,   this is done by sending a certificate with the OS APDU header (starting by 0xB006)</li> <li>We can then send the TLV signed with the CAL key, the os_pki_verify lib call will   ensure the TLV is signed by a whitelisted authority (the onboarded CAL key).</li> <li>In the test framework, we created a local fake CAL key and crafted a certificate   with TEST permissions. It be accepted by Speculos but not by a real device.</li> </ul>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#token-lookup-priority","title":"Token Lookup Priority","text":"<p>Once a dynamic token is provided via <code>PROVIDE_TOKEN_INFO</code>, the token database lookup in <code>get_token_info()</code> follows this priority:</p> <ol> <li>Dynamic token (CAL): Check a dynamic token has been received</li> <li>Hardcoded database: Check built-in token database</li> <li>Unknown: Refuses to sign. A fallback method could be implemented instead (Display token address, blind sign, ...)</li> </ol> <p>This means CAL-provided tokens override hardcoded database entries with the same address.</p>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#persistence-behavior","title":"Persistence Behavior","text":"<p>The dynamic token information is stored in RAM only (not in NVM) and persists across commands:</p> <ul> <li>Persists across <code>SIGN_TX</code> (regular transactions)</li> <li>Persists across <code>SIGN_TOKEN_TX</code> (token transactions)</li> <li>Persists across <code>GET_PUBLIC_KEY</code> and other read-only commands</li> <li>Cleared when app exits to dashboard</li> <li>Cleared after every transaction in SWAP context</li> <li>Overwritten when new <code>PROVIDE_TOKEN_INFO</code> command received (only one slot is handled)</li> </ul>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#coding_5","title":"Coding","text":""},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#command_5","title":"<code>Command</code>","text":"CLA INS P1 P2 Lc Le E0 22 00 00 variable 00"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#input-data_3","title":"<code>Input data</code>","text":"<p>The input data is a TLV-encoded descriptor with the following outer tags (all tags required, order matters for signature verification):</p> Tag Name Length Description 0x01 STRUCTURE_TYPE 1 byte Descriptor type (DYNAMIC_TOKEN = 0x90) 0x02 VERSION 1 byte Version of the serialization format 0x03 COIN_TYPE 4 bytes SLIP-44 coin type 0x04 APP_NAME var Name of the AppCoin. Case sensitive 0x05 TICKER var Token ticker that will be displayed on the device 0x06 MAGNITUDE 1 byte Decimals to format the amount in Ticker 0x07 TUID var Token Unique Identifier (app specific) 0x08 SIGNATURE [70-72] Signature of above fields <p>TUID Field (tag 0x07): The TUID field content is application specific. It is recommended to make it a nested TLV structure itself. In the Boilerplate made up implementation it contains a single tag:</p> Tag Description Length 0x10 Token address 32 bytes <p>Signature construction: The signature (tag 0x08) is computed over all tags EXCEPT tag 0x08 itself. In production context, the CAL is responsible for this signature. In our test framework, we use a mock CAL to dynamically craft signatures.</p>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#output-data_5","title":"<code>Output data</code>","text":"<p>None (returns 0x9000 on success)</p>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#example-tlv-structure","title":"<code>Example TLV structure</code>","text":"<pre><code>01 01 90                    # STRUCTURE_TYPE = DYNAMIC_TOKEN (0x90)\n02 01 01                    # VERSION = 1\n03 04 80 00 80 01           # CHAIN_ID = 0x80008001 (hardened 0x8001)\n04 01 00                    # SIGNER_ALGO = SECP256K1 (0x00)\n05 01 08                    # SIGNER_KEY = COIN_META (0x08)\n06 40 &lt;64 bytes signature&gt;  # DER_SIGNATURE (r || s)\n07 22                       # TUID length (34 bytes including sub-TLV)\n   10 20 &lt;32 bytes&gt;         #   Sub-tag 0x10: token address\n08 07                       # APP_DATA length (7 bytes)\n   04 55534454              #   Ticker length (4) + \"USDT\"\n   06                       #   Decimals (6)\n</code></pre>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#errors","title":"<code>Errors</code>","text":"SW Description B009 SW_INVALID_DYNAMIC_TOKEN - TLV parsing failed, signature verification failed, wrong coin type, or TUID validation failed 6A86 SWO_INCORRECT_P1_P2 - P1 or P2 not zero 6A87 SWO_WRONG_DATA_LENGTH - Invalid TLV structure length <p>Note on testing: Speculos emulator accepts test PKI certificates for signature validation, but real Ledger devices reject them. This is a OS security feature independent of application code or build flags.</p>"},{"location":"deps/app-boilerplate/APP_SPECIFICATION/#status-words","title":"Status Words","text":"<p>The following standard Status Words are returned for all APDUs.</p> SW SW name Description 6985 SWO_CONDITIONS_NOT_SATISFIED Rejected by user 6A86 SWO_INCORRECT_P1_P2 Either P1 or P2 is incorrect 6A87 SWO_WRONG_DATA_LENGTH Lc or minimum APDU length is incorrect 6D00 SWO_INVALID_INS No command exists with INS 6E00 SWO_INVALID_CLA Bad CLA used for this application 6A80 SWO_INCORRECT_DATA Failed to parse raw transaction 6985 SWO_CONDITIONS_NOT_SATISFIED Security issue with bad state 6600 SWO_SECURITY_ISSUE Signature of raw transaction failed B009 SW_INVALID_DYNAMIC_TOKEN Dynamic token TLV parsing/validation failed 9000 OK Success"},{"location":"deps/app-boilerplate/CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"deps/app-boilerplate/CHANGELOG/#210-2023-10-06","title":"[2.1.0] - 2023-10-06","text":""},{"location":"deps/app-boilerplate/CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Improving the settings use case in order to be able to use app settings parameters stored in NVM</li> <li>add a NBGL use case choice when a setting switch is toggled</li> </ul>"},{"location":"deps/app-boilerplate/CHANGELOG/#200-2023-07-10","title":"[2.0.0] - 2023-07-10","text":""},{"location":"deps/app-boilerplate/CHANGELOG/#added","title":"Added","text":"<ul> <li>Stax porting</li> <li>Extensive CI, including mandatory <code>guidelines_enforcer.yml</code></li> <li>Extensive <code>README.md</code> to modify/compile/test the application on most OS (Linux, MacOS, Windows)</li> <li>Extensive <code>Ragger</code> tests</li> </ul>"},{"location":"deps/app-boilerplate/CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>Simplified <code>Makefile</code> (complexity delegated to the SDK's <code>Makefile.standard_app</code>)</li> <li>Simplified overall code (moved into the SDK)</li> <li>Improving several UI flows to fit Ledger UI guidelines</li> <li>Removing <code>TRY</code>/<code>CATCH</code> usage (using <code>_no_throw</code> SDK functions)</li> <li>Cleaning unnecessary resources (moved into the SDK)</li> </ul>"},{"location":"deps/app-boilerplate/CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Multiple minor lint, prototype or misspell fixes</li> </ul>"},{"location":"deps/app-boilerplate/CHANGELOG/#101-2021-01-11","title":"[1.0.1] - 2021-01-11","text":""},{"location":"deps/app-boilerplate/CHANGELOG/#fix","title":"Fix","text":"<ul> <li>Missing header includes</li> </ul>"},{"location":"deps/app-boilerplate/CHANGELOG/#100-2020-11-19","title":"[1.0.0] - 2020-11-19","text":""},{"location":"deps/app-boilerplate/CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Initial commit with the brand new Boilerplate application</li> </ul>"},{"location":"deps/app-boilerplate/LICENSE/","title":"LICENSE","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy] [name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"deps/app-boilerplate/doc/APDU/","title":"Application Protocol Data Unit (APDU)","text":"<p>The communication protocol used by BOLOS to exchange APDU is very close to ISO 7816-4 with a few differences:</p> <ul> <li><code>Lc</code> length is always exactly 1 byte</li> <li>No <code>Le</code> field in APDU command</li> <li>Maximum size of APDU command is 260 bytes: 5 bytes of header + 255 bytes of data</li> <li>Maximum size of APDU response is 260 bytes: 258 bytes of response data + 2 bytes of status word</li> </ul> <p>Status words tend to be similar to common APDU responses in the industry.</p>"},{"location":"deps/app-boilerplate/doc/APDU/#command-apdu","title":"Command APDU","text":"Field name Length (bytes) Description CLA 1 Instruction class - indicates the type of command INS 1 Instruction code - indicates the specific command P1 1 Instruction parameter 1 for the command P2 1 Instruction parameter 2 for the command Lc 1 The number of bytes of command data to follow (a value from 0 to 255) CData var Command data with <code>Lc</code> bytes"},{"location":"deps/app-boilerplate/doc/APDU/#response-apdu","title":"Response APDU","text":"Field name Length (bytes) Description RData var Response data (can be empty) SW 2 Status word containing command processing status (e.g. <code>0x9000</code> for success)"},{"location":"deps/app-boilerplate/doc/TRANSACTION/","title":"BOLOK Transaction Serialization","text":""},{"location":"deps/app-boilerplate/doc/TRANSACTION/#overview","title":"Overview","text":"<p>The custom transaction serialization presented is for the purely fictitious BOLOK chain which has been inspired by other popular blockchain (see Links).</p>"},{"location":"deps/app-boilerplate/doc/TRANSACTION/#amount-units","title":"Amount units","text":"<p>The base unit in BOLOK chain is the BOL and the smallest unit used in raw transaction is the bolino or mBOL: 1 BOL = 1000 mBOL.</p>"},{"location":"deps/app-boilerplate/doc/TRANSACTION/#address-format","title":"Address format","text":"<p>BOLOK addresses are hexadecimal numbers, identifiers derived from the last 20 bytes of the Keccak-256 hash of the public key.</p>"},{"location":"deps/app-boilerplate/doc/TRANSACTION/#structure","title":"Structure","text":""},{"location":"deps/app-boilerplate/doc/TRANSACTION/#regular-transaction","title":"Regular Transaction","text":"Field Size (bytes) Description <code>nonce</code> 8 A sequence number used to prevent message replay <code>to</code> 20 The destination address <code>value</code> 8 The amount in mBOL to send to the destination address <code>memo_len</code> 1-9 length of the memo as varint <code>memo</code> var A text ASCII-encoded of length <code>memo_len</code> to show your love <code>v</code> 1 0x01 if y-coordinate of R is odd, 0x00 otherwise <code>r</code> 32 x-coordinate of R in ECDSA signature <code>s</code> 32 x-coordinate of S in ECDSA signature"},{"location":"deps/app-boilerplate/doc/TRANSACTION/#token-transaction","title":"Token Transaction","text":"Field Size (bytes) Description <code>nonce</code> 8 A sequence number used to prevent message replay <code>to</code> 20 The destination address <code>token_address</code> 32 The 32-byte token contract address (must be in token database) <code>value</code> 8 The amount in token's smallest unit to send <code>memo_len</code> 1-9 length of the memo as varint <code>memo</code> var A text ASCII-encoded of length <code>memo_len</code> to show your love <code>v</code> 1 0x01 if y-coordinate of R is odd, 0x00 otherwise <code>r</code> 32 x-coordinate of R in ECDSA signature <code>s</code> 32 x-coordinate of S in ECDSA signature <p>Note: Token transactions use the SIGN_TOKEN_TX command (INS 0x07) and include a 32-byte token address. The token must exist in the hardcoded token database or dynamically received for the transaction to be valid. The value is interpreted using the token's specific decimal places (12 or 14 decimals).</p> <p>Note: This implementation is for demonstration purposes only. It showcases dynamic token TLV (Type-Length-Value) handling and uses a hardcoded token database. This is not intended for actual blockchain use and should not be deployed in production environments.</p> <p>These token transactions are pure examples designed to illustrate:</p> <ul> <li>How to parse and process token metadata using TLV encoding</li> <li>Dynamic handling of token information structures</li> <li>Mock token database integration for testing and development</li> </ul>"},{"location":"deps/app-boilerplate/doc/TRANSACTION/#variable-length-integer-varint","title":"Variable length integer (varint)","text":"<p>Integer can be encoded depending on the represented value to save space. Variable length integers always precede an array of a type of data that may vary in length. Longer numbers are encoded in little endian.</p> Value Storage length (bytes) Format &lt; 0xFD 1 uint8_t &lt;= 0xFFFF 3 0xFD followed by the length as uint16_t &lt;= 0xFFFF FFFF 5 0xFE followed by the length as uint32_t - 9 0xFF followed by the length as uint64_t"},{"location":"deps/app-boilerplate/doc/TRANSACTION/#signature","title":"Signature","text":"<p>Deterministic ECDSA (RFC 6979) is used to sign transaction on the SECP-256k1 curve. The signed message is <code>m = Keccak-256(nonce || to || value || memo_len || memo)</code>.</p>"},{"location":"deps/app-boilerplate/doc/TRANSACTION/#fee","title":"Fee","text":"<p>You won't find any fee in the transaction structure because the BOLOK chain has constant fees.</p>"},{"location":"deps/app-boilerplate/doc/TRANSACTION/#links","title":"Links","text":"<ul> <li>Bitcoin Transaction</li> <li>Ethereum Transaction</li> </ul>"},{"location":"deps/app-boilerplate/fuzzing/","title":"Fuzzing on transaction parser","text":""},{"location":"deps/app-boilerplate/fuzzing/#fuzzing","title":"Fuzzing","text":"<p>Fuzzing allows us to test how a program behaves when provided with invalid, unexpected, or random data as input.</p> <p>In the case of <code>app-boilerplate</code> we want to test the code that is responsible for parsing the transaction data, which is <code>transaction_deserialize()</code>. To test <code>transaction_deserialize()</code>, our fuzz target, <code>fuzz_tx_parser.c</code>, needs to implement <code>int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)</code>, which provides an array of random bytes that can be used to simulate a serialized transaction. If the application crashes, or a sanitizer detects any kind of access violation, the fuzzing process is stopped, a report regarding the vulnerability is shown, and the input that triggered the bug is written to disk under the name <code>crash-*</code>. The vulnerable input file created can be passed as an argument to the fuzzer to triage the issue.</p> <p>Note: Usually we want to write a separate fuzz target for each functionality.</p>"},{"location":"deps/app-boilerplate/fuzzing/#manual-usage-based-on-ledger-container","title":"Manual usage based on Ledger container","text":""},{"location":"deps/app-boilerplate/fuzzing/#preparation","title":"Preparation","text":"<p>The fuzzer can run from the docker <code>ledger-app-builder-legacy</code>. You can download it from the <code>ghcr.io</code> docker repository:</p> <pre><code>sudo docker pull ghcr.io/ledgerhq/ledger-app-builder/ledger-app-builder-legacy:latest\n</code></pre> <p>You can then enter this development environment by executing the following command from the repository root directory:</p> <pre><code>sudo docker run --rm -ti --user \"$(id -u):$(id -g)\" -v \"$(realpath .):/app\" ghcr.io/ledgerhq/ledger-app-builder/ledger-app-builder-legacy:latest\n</code></pre>"},{"location":"deps/app-boilerplate/fuzzing/#compilation","title":"Compilation","text":"<p>Once in the container, go into the <code>fuzzing</code> folder to compile the fuzzer:</p> <pre><code>cd fuzzing\n\n# cmake initialization\ncmake -DBOLOS_SDK=/opt/ledger-secure-sdk -DCMAKE_C_COMPILER=/usr/bin/clang -Bbuild -H.\n\n# Fuzzer compilation\nmake -C build\n</code></pre>"},{"location":"deps/app-boilerplate/fuzzing/#run","title":"Run","text":"<pre><code>./build/fuzz_tx_parser\n</code></pre>"},{"location":"deps/app-boilerplate/fuzzing/#full-usage-based-on-clusterfuzzlite-container","title":"Full usage based on <code>clusterfuzzlite</code> container","text":"<p>Exactly the same context as the CI, directly using the <code>clusterfuzzlite</code> environment.</p> <p>More info can be found here: https://google.github.io/clusterfuzzlite/</p>"},{"location":"deps/app-boilerplate/fuzzing/#preparation_1","title":"Preparation","text":"<p>The principle is to build the container, and run it to perform the fuzzing.</p> <p>Note: The container contains a copy of the sources (they are not cloned), which means the <code>docker build</code> command must be re-executed after each code modification.</p> <pre><code># Prepare directory tree\nmkdir fuzzing/{corpus,out}\n# Container generation\ndocker build -t app-boilerplate --file .clusterfuzzlite/Dockerfile .\n</code></pre>"},{"location":"deps/app-boilerplate/fuzzing/#compilation_1","title":"Compilation","text":"<pre><code>docker run --rm --privileged -e FUZZING_LANGUAGE=c -v \"$(realpath .)/fuzzing/out:/out\" -ti app-boilerplate\n</code></pre>"},{"location":"deps/app-boilerplate/fuzzing/#run_1","title":"Run","text":"<pre><code>docker run --rm --privileged -e FUZZING_ENGINE=libfuzzer -e RUN_FUZZER_MODE=interactive -v \"$(realpath .)/fuzzing/corpus:/tmp/fuzz_corpus\" -v \"$(realpath .)/fuzzing/out:/out\" -ti gcr.io/oss-fuzz-base/base-runner run_fuzzer fuzz_tx_parser\n</code></pre>"},{"location":"deps/app-boilerplate/src/token/","title":"Token Support in Boilerplate App","text":"<p>This directory contains the token infrastructure for the Boilerplate application, demonstrating three levels of token support.</p>"},{"location":"deps/app-boilerplate/src/token/#token-support-levels","title":"Token Support Levels","text":""},{"location":"deps/app-boilerplate/src/token/#1-hardcoded-tokens-simple-use-freely","title":"1. Hardcoded Tokens (Simple - Use Freely)","text":"<p>Location: <code>token_db.c</code> / <code>token_db.h</code></p> <p>Use case: You have a fixed set of tokens to support</p> <p>Implementation:</p> <ul> <li>Add token metadata directly in <code>TOKENS</code> array</li> <li>No coordination with Ledger needed</li> <li>Works for both send and swap operations</li> <li>Recommended for most third-party apps</li> </ul> <p>Example:</p> <pre><code>{\n    .address = \"0123456789abcdef...\",  // 32-byte hex token address\n    .ticker = \"USDC\",\n    .decimals = 12\n}\n</code></pre> <p>Limitations:</p> <ul> <li>Requires app update to add new tokens</li> <li>For SWAP support, token must be added to CAL database (contact Ledger - quick process)</li> </ul>"},{"location":"deps/app-boilerplate/src/token/#2-dynamic-tokens-complex-requires-ledger-coordination","title":"2. Dynamic Tokens (Complex - Requires Ledger Coordination)","text":"<p>Location: <code>dynamic_token_info.c</code> / <code>dynamic_token_info.h</code> / <code>handler/provide_token_info.c</code></p> <p>Use case: Tokens can be added without app updates via signed descriptors</p> <p>Requirements:</p> <ul> <li>Mandatory coordination with Ledger teams</li> <li>PKI certificate management (Ledger-controlled)</li> <li>CAL descriptor signing infrastructure</li> <li>Security review and approval</li> </ul> <p>Implementation:</p> <ul> <li>Device receives TLV-encoded signed descriptor via <code>PROVIDE_TOKEN_INFO</code> APDU</li> <li>Signature validated against PKI certificates</li> <li>Token metadata stored in RAM (overrides hardcoded DB)</li> <li>Persists across commands until app exit</li> </ul> <p>When to use:</p> <ul> <li>Your chain has thousands of tokens</li> <li>Tokens are frequently added/updated</li> <li>You've coordinated with Ledger's security team</li> </ul> <p>Do NOT use if:</p> <ul> <li>You have very few tokens (use hardcoded instead)</li> <li>You want a quick integration (use hardcoded instead)</li> <li>You haven't contacted Ledger yet (contact first!)</li> </ul>"},{"location":"deps/app-boilerplate/src/token/#token-lookup-priority","title":"Token Lookup Priority","text":"<pre><code>1. Dynamic token (CAL) - if provided and address matches\n2. Hardcoded database - built-in tokens\n3. Unknown - transaction fails (a different behavior could have been coded)\n</code></pre>"},{"location":"deps/app-boilerplate/src/token/#dynamic-token-slots","title":"Dynamic Token Slots","text":"<p>The Boilerplate application handles only one slot of dynamic token descriptor. This is a design choice to keep the implementation minimalist and focused on the key parts (TLV, PKI, SDK API).</p>"},{"location":"deps/app-boilerplate/src/token/#testing","title":"Testing","text":"<ul> <li>Hardcoded tokens: You simply need to craft and send token transaction relevant to your hardcoded database.</li> <li>Dynamic tokens: More complex to test, a fake CAL must be mocked and whitelisted on the device PKI   by sending a test certificate. WILL NOT work on a real device, the test certificate will be rejected.</li> <li>SWAP tokens: Simply a token test done through the ExchangeTestRunner to emulate start from the Exchange application.</li> </ul>"},{"location":"deps/app-boilerplate/src/token/#security-notes","title":"Security Notes","text":"<ul> <li>Always validate token addresses in your app</li> <li>Hardcoded tokens are reviewed in your app's code review</li> <li>Dynamic tokens require PKI signature validation (handled by SDK)</li> <li>The fake CAL mock cannot be onboarded on a real device because the associated certificate only has test permissions</li> </ul>"},{"location":"deps/app-boilerplate/src/token/#questions","title":"Questions?","text":"<ul> <li>Hardcoded tokens: Fork and implement (no questions needed)</li> <li>Dynamic tokens: Contact Ledger developer support</li> <li>SWAP integration: Contact Ledger developer support</li> </ul>"},{"location":"deps/app-boilerplate/tests/","title":"Index","text":"<p>The <code>application_client</code> directory contains the minimalist python client for crafting and sending APDUs to the application. It is extracted in order to be able to be used in both tests setup.</p> <p>The <code>standalone</code> directory contains the standalone tests of the application, when it is started from the Dashboard of the device (main use case).</p> <p>The <code>swap</code> directory contains the tests of the SWAP feature of the application, when it is started by the Exchange application through the <code>os_lib_call</code> API. This setup needs the Exchange and Ethereum binaries compiled.</p>"},{"location":"deps/app-boilerplate/tests/application_client/","title":"Application Client for Functional Tests","text":"<p>This minimalist Python client is used in the functional tests of the boilerplate Ledger application. It serves as a communication layer between the test framework (<code>pytest</code>) and the device-under-test (Ledger app), sending commands and parsing responses.</p>"},{"location":"deps/app-boilerplate/tests/application_client/#purpose","title":"Purpose","text":"<p>This module is not intended to be a full SDK. Instead, it offers just enough abstraction to:</p> <ul> <li>Send APDUs to the application</li> <li>Decode structured responses</li> <li>Facilitate clear and maintainable test code</li> </ul> <p>It is intentionally lightweight, focusing on what is strictly necessary to write functional tests.</p>"},{"location":"deps/app-boilerplate/tests/application_client/#when-to-use","title":"When to Use","text":"<p>Use this client as-is when testing the original boilerplate application. When you fork the boilerplate to implement your own Ledger app, you can extend or modify this client to support your custom instruction set, encodings, and behavior.</p>"},{"location":"deps/app-boilerplate/tests/application_client/#structure","title":"Structure","text":"<p>The <code>application_client</code> package contains:</p> <ul> <li><code>boilerplate_command_sender.py</code> \u2014 Low-level command encoding and APDU transmission</li> <li><code>boilerplate_transaction.py</code> \u2014 Helpers to craft and serialize transactions</li> <li><code>boilerplate_response_unpacker.py</code> \u2014 Functions to decode responses from the app</li> <li><code>boilerplate_currency_utils.py</code> \u2014 Utility functions for currency-specific formatting</li> <li><code>boilerplate_utils.py</code> \u2014 Miscellaneous helpers (e.g. encoding, validation)</li> <li><code>py.typed</code> \u2014 Marker file for type checkers (e.g. <code>mypy</code>)</li> </ul>"},{"location":"deps/app-boilerplate/tests/application_client/#how-to-use","title":"How to Use","text":"<p>Look at the existing tests for example on how to use this client</p>"},{"location":"deps/app-boilerplate/tests/application_client/keychain/","title":"Index","text":"<p>The pem file(s) in this directory have been generated on the-fly and have no meaning in production context.</p>"},{"location":"deps/app-boilerplate/tests/standalone/","title":"Standalone Functional Tests","text":"<p>This directory contains the standalone functional test suite for the Ledger application. It is intended to validate the application\u2019s behavior in a generic context, when launched directly from the device's dashboard.</p> <p>These tests are written using:</p> <ul> <li>pytest \u2014 Python testing framework</li> <li>Ragger \u2014 Ledger's open-source testing library for simulating device interactions</li> </ul>"},{"location":"deps/app-boilerplate/tests/standalone/#purpose","title":"Purpose","text":"<p>The standalone test suite ensures that:</p> <ul> <li>The application launches correctly from the dashboard</li> <li>The main menu and navigation behave as expected</li> <li>Core commands (e.g., <code>GET_VERSION</code>, <code>GET_PUBLIC_KEY</code>, <code>SIGN_TX</code>) function properly</li> <li>User approval flows work under normal conditions</li> <li>Errors are correctly reported and handled</li> </ul>"},{"location":"deps/app-boilerplate/tests/standalone/#directory-structure","title":"Directory Structure","text":"<pre><code>standalone/\n\u251c\u2500\u2500 conftest.py              # Pytest fixtures and device setup\n\u251c\u2500\u2500 test_*.py                # Functional test cases\n\u251c\u2500\u2500 snapshots/               # Ragger UI snapshots\n\u251c\u2500\u2500 snapshots-tmp/           # Temporary snapshot diffs (not tracked in git)\n\u251c\u2500\u2500 requirements.txt         # Python dependencies\n\u2514\u2500\u2500 utils.py                 # Local test helpers\n</code></pre>"},{"location":"deps/app-boilerplate/tests/standalone/usage/","title":"How to use the Ragger test framework","text":"<p>This framework allows testing the application on the Speculos emulator or on a real device using LedgerComm or LedgerWallet</p>"},{"location":"deps/app-boilerplate/tests/standalone/usage/#quickly-get-started-with-ragger-and-speculos","title":"Quickly get started with Ragger and Speculos","text":""},{"location":"deps/app-boilerplate/tests/standalone/usage/#install-ragger-and-dependencies","title":"Install ragger and dependencies","text":"<pre><code>pip install --extra-index-url https://test.pypi.org/simple/ -r requirements.txt\nsudo apt-get update &amp;&amp; sudo apt-get install qemu-user-static\n</code></pre>"},{"location":"deps/app-boilerplate/tests/standalone/usage/#compile-the-application","title":"Compile the application","text":"<p>The application to test must be compiled for all required devices. You can use for this the container <code>ghcr.io/ledgerhq/ledger-app-builder/ledger-app-builder-lite</code>:</p> <pre><code>docker pull ghcr.io/ledgerhq/ledger-app-builder/ledger-app-builder-lite:latest\ncd &lt;your app repository&gt;                        # replace &lt;appname&gt; with the name of your app, (eg boilerplate)\ndocker run --user \"$(id -u)\":\"$(id -g)\" --rm -ti -v \"$(realpath .):/app\" --privileged -v \"/dev/bus/usb:/dev/bus/usb\" ledger-app-builder-lite:latest\nmake clean &amp;&amp; make BOLOS_SDK=$&lt;device&gt;_SDK      # replace &lt;device&gt; with one of [NANOX, NANOSP, STAX, FLEX, APEX]\nexit\n</code></pre>"},{"location":"deps/app-boilerplate/tests/standalone/usage/#run-a-simple-test-using-the-speculos-emulator","title":"Run a simple test using the Speculos emulator","text":"<p>You can use the following command to get your first experience with Ragger and Speculos</p> <pre><code>pytest -v --tb=short --device nanox --display\n</code></pre> <p>Or you can refer to the section <code>Available pytest options</code> to configure the options you want to use</p>"},{"location":"deps/app-boilerplate/tests/standalone/usage/#run-a-simple-test-using-a-real-device","title":"Run a simple test using a real device","text":"<p>The application to test must be loaded and started on a Ledger device plugged in USB. You can use for this the container <code>ghcr.io/ledgerhq/ledger-app-builder/ledger-app-builder-lite</code>:</p> <pre><code>docker pull ghcr.io/ledgerhq/ledger-app-builder/ledger-app-builder-lite:latest\ncd app-&lt;appname&gt;/                                   # replace &lt;appname&gt; with the name of your app, (eg boilerplate)\ndocker run --user \"$(id -u)\":\"$(id -g)\" --rm -ti -v \"$(realpath .):/app\" --privileged -v \"/dev/bus/usb:/dev/bus/usb\" ledger-app-builder-lite:latest\nmake clean &amp;&amp; make BOLOS_SDK=$&lt;device&gt;_SDK load     # replace &lt;device&gt; with one of [NANOX, NANOSP, STAX, FLEX, APEX]\nexit\n</code></pre> <p>You can use the following command to get your first experience with Ragger and Ledgerwallet on a NANOX. Make sure that the device is plugged, unlocked, and that the tested application is open.</p> <pre><code>pytest -v --tb=short --device nanox --backend ledgerwallet\n</code></pre> <p>Or you can refer to the section <code>Available pytest options</code> to configure the options you want to use</p>"},{"location":"deps/app-boilerplate/tests/standalone/usage/#available-pytest-options","title":"Available pytest options","text":"<p>Standard useful pytest options</p> <pre><code>    -v              formats the test summary in a readable way\n    -s              enable logs for successful tests, on Speculos it will enable app logs if compiled with DEBUG=1\n    -k &lt;testname&gt;   only run the tests that contain &lt;testname&gt; in their names\n    --tb=short      in case of errors, formats the test traceback in a readable way\n</code></pre> <p>Custom pytest options</p> <pre><code>    --device &lt;device&gt;           run the test on the specified device [nanox,nanosp,stax,flex,all]. This parameter is mandatory\n    --backend &lt;backend&gt;         run the tests against the backend [speculos, ledgercomm, ledgerwallet]. Speculos is the default\n    --display                   on Speculos, enables the display of the app screen using QT\n    --golden_run                on Speculos, screen comparison functions will save the current screen instead of comparing\n    --log_apdu_file &lt;filepath&gt;  log all apdu exchanges to the file in parameter. The previous file content is erased\n</code></pre>"},{"location":"deps/app-boilerplate/tests/swap/","title":"Index","text":""},{"location":"deps/app-boilerplate/tests/swap/#the-swap-functional-tests-setup","title":"The Swap functional tests setup","text":"<p>The swap test suite validates the application when it is used by the Exchange application through the os_lib_call mechanism to perform the swap feature.</p> <p>This mode uses dedicated launch code and requires a different Speculos setup.</p> <p>These tests are written using:</p> <ul> <li>pytest \u2014 Python testing framework</li> <li>Ragger \u2014 Ledger's open-source testing library for simulating device interactions</li> <li>The python module ledger_app_clients.exchange,   the helper module to easily emulate the SWAP context.</li> </ul> <p>Directory structure brief overview:</p> <pre><code>swap/\n|\u2500\u2500 cal_helper.py                     # A fake CAL configuration for the BOL currency\n\u251c\u2500\u2500 conftest.py                       # Pytest fixtures and device setup\n\u251c\u2500\u2500 test_boilerplate.py               # Functional test cases\n\u251c\u2500\u2500 helper_tool_build_dependencies.py # A helper script to pull Exchange and Ethereum applications (needed for Speculos to emulate a swap)\n\u251c\u2500\u2500 helper_tool_clone_dependencies.py # A helper script to compile pulled Exchange and Ethereum applications (run after helper_tool_build_dependencies.py INSIDE the Docker)\n\u251c\u2500\u2500 snapshots/                        # Ragger UI snapshots\n\u251c\u2500\u2500 snapshots-tmp/                    # Temporary snapshot diffs (not tracked in git)\n\u251c\u2500\u2500 requirements.txt                  # Python dependencies\n</code></pre>"},{"location":"deps/app-boilerplate/tests/swap/#compile-your-application","title":"Compile your application","text":"<p>Build your application in the Ledger docker environment.</p>"},{"location":"deps/app-boilerplate/tests/swap/#compile-the-exchange-and-ethereum-applications","title":"Compile the Exchange and Ethereum applications","text":"<p>First, install helper python dependencies in your native (host) environment</p> <pre><code>pip install -U GitPython\n</code></pre> <p>Then, execute the clone script in your native (host) environment</p> <pre><code>python helper_tool_clone_dependencies.py\n</code></pre> <p>Then, execute the build script in the Ledger docker environment. You can use the following command when located in the <code>tests/swap</code> directory.</p> <pre><code>docker run --user \"$(id -u)\":\"$(id -g)\" --rm -ti -v \"$(realpath .):/app\" \"ghcr.io/ledgerhq/ledger-app-builder/ledger-app-builder:latest\" python3 helper_tool_build_dependencies.py\n</code></pre>"},{"location":"deps/app-boilerplate/tests/swap/#running-a-first-exchange-test","title":"Running a first Exchange test","text":"<p>If you are on Linux or WSL, you can run the tests in your native (host) environment.</p> <p>If you are on MAC you need to run the tests in the Ledger docker environment.</p>"},{"location":"deps/app-boilerplate/tests/swap/#install-python-dependencies","title":"Install python dependencies","text":"<p>Install python dependencies</p> <pre><code>pip install -r tests/swap/requirements.txt --break-system-packages\n</code></pre>"},{"location":"deps/app-boilerplate/tests/swap/#run-a-simple-test","title":"Run a simple test","text":"<p>To see all available tests:</p> <pre><code>pytest -v --tb=short tests/swap/ --device all --collect-only\n</code></pre> <p>To list only SWAP tests for Stax:</p> <pre><code>pytest -v --tb=short tests/swap/ --device stax --collect-only -k swap\n</code></pre> <p>To run a specific test for Stax:</p> <pre><code>pytest -v --tb=short tests/swap/ --device stax -k 'swap_ui_only' -s\n</code></pre> <p>Running a single test will be useful later for test driven development, don't hesitate to come back to this command and adapt it.</p>"},{"location":"deps/app-boilerplate/unit-tests/","title":"Unit tests","text":""},{"location":"deps/app-boilerplate/unit-tests/#prerequisite","title":"Prerequisite","text":"<p>Be sure to have installed:</p> <ul> <li>CMake &gt;= 3.10</li> <li>CMocka &gt;= 1.1.5</li> </ul> <p>and for code coverage generation:</p> <ul> <li>lcov &gt;= 1.14</li> </ul>"},{"location":"deps/app-boilerplate/unit-tests/#overview","title":"Overview","text":"<p>In <code>unit-tests</code> folder, compile with</p> <pre><code>cmake -Bbuild -H. &amp;&amp; make -C build\n</code></pre> <p>and run tests with</p> <pre><code>CTEST_OUTPUT_ON_FAILURE=1 make -C build test\n</code></pre>"},{"location":"deps/app-boilerplate/unit-tests/#generate-code-coverage","title":"Generate code coverage","text":"<p>Just execute in <code>unit-tests</code> folder</p> <pre><code>./gen_coverage.sh\n</code></pre> <p>it will output <code>coverage.total</code> and <code>coverage/</code> folder with HTML details (in <code>coverage/index.html</code>).</p>"},{"location":"deps/app-solana/","title":"Index","text":""},{"location":"deps/app-solana/#solana-app-for-ledger-wallet","title":"Solana app for Ledger Wallet","text":""},{"location":"deps/app-solana/#overview","title":"Overview","text":"<p>This app adds support for the Solana native token to Ledger Nano S hardware wallet.</p> <p>Current Features: - Pubkey queries - Parse, display and sign all Solana CLI generated transaction formats - Blind sign arbitrary transactions (Enabled via settings)</p>"},{"location":"deps/app-solana/#prerequisites","title":"Prerequisites","text":""},{"location":"deps/app-solana/#for-building-the-app","title":"For building the app","text":"<ul> <li>Install Docker</li> <li>For Linux hosts, install the Ledger Nano udev rules</li> <li>Pull Ledger Development Tools image</li> </ul> <pre><code>$ docker pull ghcr.io/ledgerhq/ledger-app-builder/ledger-app-dev-tools:latest\n</code></pre>"},{"location":"deps/app-solana/#build","title":"Build","text":"<p>Build the app in the container. The BOLOS_SDK variable is used to specify the target SDK, allowing to compile the application for each Ledger device. See Ledger Application Builder for more details.</p> <pre><code># E.g. for Nano S\n$ sudo docker run --rm -ti -v \"$(realpath .):/app\" --user $(id -u $USER):$(id -g $USER) ghcr.io/ledgerhq/ledger-app-builder//ledger-app-dev-tools:latest\nbash$ BOLOS_SDK=$NANOS_SDK make\n</code></pre>"},{"location":"deps/app-solana/#clean","title":"Clean","text":"<p>Within the running development container</p> <pre><code>bash$ BOLOS_SDK=$NANOS_SDK make clean\n</code></pre>"},{"location":"deps/app-solana/#working-with-the-device","title":"Working with the device","text":"<p>See Ledger Application Builder for more details. </p>"},{"location":"deps/app-solana/#load","title":"Load","text":"<pre><code>$ sudo docker run --rm -ti  -v \"$(realpath .):/app\" --privileged -v \"/dev/bus/usb:/dev/bus/usb\" --user $(id -u $USER):$(id -g $USER) ghcr.io/ledgerhq/ledger-app-builder/ledger-app-dev-tools:latest\nbash$ BOLOS_SDK=$NANOS_SDK make load\n</code></pre>"},{"location":"deps/app-solana/#delete","title":"Delete","text":"<p>Within the running development container</p> <pre><code>bash$ BOLOS_SDK=$NANOS_SDK make delete\n</code></pre>"},{"location":"deps/app-solana/#test","title":"Test","text":""},{"location":"deps/app-solana/#unit","title":"Unit","text":"<p>Run C tests:</p> <pre><code>bash$ make -C libsol\n</code></pre>"},{"location":"deps/app-solana/#ragger","title":"Ragger","text":"<p>Make sure that you have already built the application for the specific device.</p> <p>Run Ragger tests:</p> <pre><code># Install python test suite dependencies\nbash$ pip install -r \"tests/python/requirements.txt\"\n\n# Run test suite for the specific device, e.g. nanos\nbash$ pytest tests/python/ --tb=short -v --device nanos -k \"\"\n</code></pre> <p>To regenerate golden snapshots, use <code>--golden_run</code> option.</p>"},{"location":"deps/app-solana/#integration","title":"Integration","text":"<p>First enable <code>blind-signing</code> in the App settings</p> <pre><code>bash$ cargo run --manifest-path tests/Cargo.toml\n</code></pre>"},{"location":"deps/app-solana/doc/api/","title":"Solana application : Common Technical Specifications","text":""},{"location":"deps/app-solana/doc/api/#140","title":"1.4.0","text":"<ul> <li>Add support of Trusted Name descriptor (checked by PKI certificate)</li> </ul>"},{"location":"deps/app-solana/doc/api/#131","title":"1.3.1","text":"<ul> <li>Add support for versioned messages</li> </ul>"},{"location":"deps/app-solana/doc/api/#130","title":"1.3.0","text":"<ul> <li>Add SIGN SOLANA OFF-CHAIN MESSAGE</li> <li>Add compatibility with the Exchange Application to SWAP, FUND, or SELL SOL tokens</li> </ul>"},{"location":"deps/app-solana/doc/api/#about","title":"About","text":"<p>This application describes the APDU messages interface to communicate with the Solana application.</p> <p>The application covers the following functionalities :</p> <ul> <li>Retrieve an address given an account number</li> <li>Sign Solana transaction</li> <li>Sign off-chain message</li> </ul> <p>The application interface can be accessed over HID or BLE</p>"},{"location":"deps/app-solana/doc/api/#general-purpose-apdus","title":"General purpose APDUs","text":""},{"location":"deps/app-solana/doc/api/#get-app-configuration","title":"GET APP CONFIGURATION","text":""},{"location":"deps/app-solana/doc/api/#description","title":"Description","text":"<p>This command returns specific application configuration</p>"},{"location":"deps/app-solana/doc/api/#command","title":"Command","text":"CLA INS P1 P2 Lc Le E0 04 00 00 00 04"},{"location":"deps/app-solana/doc/api/#input-data","title":"Input data","text":"<p>None</p>"},{"location":"deps/app-solana/doc/api/#output-data","title":"Output data","text":"Description Length Dummy setting n\u00b01 value 01 Dummy setting n\u00b02 value 01 Application major version 01 Application minor version 01 Application patch version 01"},{"location":"deps/app-solana/doc/api/#get-pubkey","title":"GET PUBKEY","text":""},{"location":"deps/app-solana/doc/api/#description_1","title":"Description","text":"<p>This command returns a Solana pubkey for the given BIP 32 path</p>"},{"location":"deps/app-solana/doc/api/#command_1","title":"Command","text":"CLA INS P1 P2 Lc Le E0 05 00 00 variable variable"},{"location":"deps/app-solana/doc/api/#input-data_1","title":"Input data","text":"Description Length Number of BIP 32 derivations to perform (3 or 4) 1 First derivation index (big endian) 4 ... 4 Last derivation index (big endian) 4"},{"location":"deps/app-solana/doc/api/#output-data_1","title":"Output data","text":"Description Length Pubkey 32"},{"location":"deps/app-solana/doc/api/#sign-solana-transaction","title":"SIGN SOLANA TRANSACTION","text":""},{"location":"deps/app-solana/doc/api/#description_2","title":"Description","text":"<p>This command signs a Solana Transaction after having the user validate the transaction-specific parameters:</p>"},{"location":"deps/app-solana/doc/api/#command_2","title":"Command","text":"CLA INS P1 P2 Lc Le E0 06 01 00 variable variable"},{"location":"deps/app-solana/doc/api/#input-data_2","title":"Input data","text":"Description Length Number of signers (derivation paths) (always 1) 1 Number of BIP 32 derivations to perform (2, 3 or 4) 1 First derivation index (big endian) 4 ... 4 Last derivation index (big endian) 4 Serialized transaction variable"},{"location":"deps/app-solana/doc/api/#output-data_2","title":"Output data","text":"Description Length Signature 64"},{"location":"deps/app-solana/doc/api/#sign-solana-off-chain-message","title":"SIGN SOLANA OFF-CHAIN MESSAGE","text":""},{"location":"deps/app-solana/doc/api/#description_3","title":"Description","text":"<p>This command signs a Solana Off-Chain Message after having the user validate the text of ASCII encoded messages, or hash of UTF-8 encoded messages:</p>"},{"location":"deps/app-solana/doc/api/#command_3","title":"Command","text":"CLA INS P1 P2 Lc Le E0 07 01 00 variable variable"},{"location":"deps/app-solana/doc/api/#input-data_3","title":"Input data","text":"Description Length Number of signers (derivation paths) (always 1) 1 Number of BIP 32 derivations to perform (2, 3 or 4) 1 First derivation index (big endian) 4 ... 4 Last derivation index (big endian) 4 Serialized off-chain message variable"},{"location":"deps/app-solana/doc/api/#output-data_3","title":"Output data","text":"Description Length Signature 64"},{"location":"deps/app-solana/doc/api/#get-challenge","title":"GET CHALLENGE","text":""},{"location":"deps/app-solana/doc/api/#description_4","title":"Description","text":"<p>_This command returns a 32-bit challenge generated by the app</p>"},{"location":"deps/app-solana/doc/api/#command_4","title":"Command","text":"CLA INS P1 P2 Lc Le E0 20 00 00 00 N/A"},{"location":"deps/app-solana/doc/api/#input-data_4","title":"Input data","text":"<p>N/A</p>"},{"location":"deps/app-solana/doc/api/#output-data_4","title":"Output data","text":"Description Length Challenge 4"},{"location":"deps/app-solana/doc/api/#provide-trusted-name-tlv-descriptor","title":"PROVIDE TRUSTED NAME TLV DESCRIPTOR","text":""},{"location":"deps/app-solana/doc/api/#description_5","title":"Description","text":"<p>_This command provides a Solana Trusted Name TLV descriptor</p>"},{"location":"deps/app-solana/doc/api/#command_5","title":"Command","text":"CLA INS P1 P2 Lc Le E0 21 00 00 F7 (max) variable"},{"location":"deps/app-solana/doc/api/#input-data_5","title":"Input data","text":"Description Length Serialized signed TLV descriptor payload variable"},{"location":"deps/app-solana/doc/api/#output-data_5","title":"Output data","text":"<p>N/A</p>"},{"location":"deps/app-solana/doc/api/#transport-protocol","title":"Transport protocol","text":""},{"location":"deps/app-solana/doc/api/#general-transport-description","title":"General transport description","text":"<p>Ledger APDUs requests and responses are encapsulated using a flexible protocol allowing to fragment large payloads over different underlying transport mechanisms.</p> <p>The common transport header is defined as follows:</p> Description Length Communication channel ID (big endian) 2 Command tag 1 Packet sequence index (big endian) 2 Payload var <p>The Communication channel ID allows commands multiplexing over the same physical link. It is not used for the time being, and should be set to 0101 to avoid compatibility issues with implementations ignoring a leading 00 byte.</p> <p>The Command tag describes the message content. Use TAG_APDU (0x05) for standard APDU payloads, or TAG_PING (0x02) for a simple link test.</p> <p>The Packet sequence index describes the current sequence for fragmented payloads. The first fragment index is 0x00.</p>"},{"location":"deps/app-solana/doc/api/#apdu-command-payload-encoding","title":"APDU Command payload encoding","text":"<p>APDU Command payloads are encoded as follows :</p> Description Length APDU length (big endian) 2 APDU CLA 1 APDU INS 1 APDU P1 1 APDU P2 1 APDU data length 1 Optional APDU data var <p>APDU payload is encoded according to the APDU case</p> Case Number Lc Le Case description 1 0 0 No data in either direction - L is set to 00 2 0 !0 Input Data present, no Output Data - L is set to Lc 3 !0 0 Output Data present, no Input Data - L is set to Le 4 !0 !0 Both Input and Output Data are present - L is set to Lc"},{"location":"deps/app-solana/doc/api/#deprecation-notice","title":"Deprecation notice","text":"<p>The <code>ADPU data length</code> field was formerly serialized as a 16bit unsigned big endian integer. As of version 0.2.0, this has been changed to an 8bit unsigned integer to improve compatibility with client libraries. In doing so, the following instructions have been deprecated.</p> <ul> <li>0x01 - GET_APP_CONFIGURATION</li> <li>0x02 - GET_PUBKEY</li> <li>0x03 - SIGN_MESSAGE</li> </ul>"},{"location":"deps/app-solana/doc/api/#apdu-response-payload-encoding","title":"APDU Response payload encoding","text":"<p>APDU Response payloads are encoded as follows :</p> Description Length APDU response length (big endian) 2 APDU response data and Status Word var"},{"location":"deps/app-solana/doc/api/#usb-mapping","title":"USB mapping","text":"<p>Messages are exchanged with the dongle over HID endpoints over interrupt transfers, with each chunk being 64 bytes long. The HID Report ID is ignored.</p>"},{"location":"deps/app-solana/doc/api/#ble-mapping","title":"BLE mapping","text":"<p>A similar encoding is used over BLE, without the Communication channel ID.</p> <p>The application acts as a GATT server defining service UUID D973F2E0-B19E-11E2-9E96-0800200C9A66</p> <p>When using this service, the client sends requests to the characteristic D973F2E2-B19E-11E2-9E96-0800200C9A66, and gets notified on the characteristic D973F2E1-B19E-11E2-9E96-0800200C9A66 after registering for it.</p> <p>Requests are encoded using the standard BLE 20 bytes MTU size</p>"},{"location":"deps/app-solana/doc/api/#status-words","title":"Status Words","text":"<p>The following standard Status Words are returned for all APDUs - some specific Status Words can be used for specific commands and are mentioned in the command description.</p>"},{"location":"deps/app-solana/doc/api/#status-words_1","title":"Status Words","text":"SW Description 6700 Incorrect length 6982 Security status not satisfied (Canceled by user) 6A80 Invalid data 6A81 Invalid off-chain message header 6A82 Invalid off-chain message format 6B00 Incorrect parameter P1 or P2 6Fxx Technical problem (Internal error, please report) 9000 Normal ending of the command"},{"location":"deps/app-solana/doc/fuzzing/","title":"Fuzzing","text":"<p>Building the fuzzer requires Clang and CMake.</p> <p>To quickly get started fuzzing Solana message parserusing libFuzzer:</p> <pre><code>cd fuzzing\n./build.sh\n./run.sh\n</code></pre> <p>Initial corpus has been generated from the testcases found in the <code>libsol</code> directory.</p>"},{"location":"deps/app-solana/doc/fuzzing/#code-coverage","title":"Code coverage","text":"<p>To generate a code coverage report of the fuzzer, it is possible to use <code>llvm-cov</code> (on Ubuntu: <code>sudo apt install llvm</code>):</p> <pre><code>cd fuzzing\n./coverage.sh\n</code></pre> <p>These commands generate a HTML report in <code>fuzzing/html-coverage/index.html</code>.</p>"},{"location":"deps/app-solana/tests/swap/","title":"Swap Functional Tests","text":"<p>The swap test suite validates the application when it is used by the Exchange application through the os_lib_call mechanism to perform swaps.</p> <p>This mode uses dedicated launch code and requires a different Speculos setup.</p> <p>These tests are written using:</p> <ul> <li>pytest \u2014 Python testing framework</li> <li>Ragger \u2014 Ledger's open-source testing library for simulating device interactions</li> <li>The python module ledger_app_clients.exchange - The helper module to easily emulate the SWAP context.</li> </ul>"},{"location":"deps/app-solana/tests/swap/#purpose","title":"Purpose","text":"<p>The standalone test suite ensures that the application implements correctly the swap feature</p>"},{"location":"deps/app-solana/tests/swap/#directory-structure","title":"Directory Structure","text":"<pre><code>swap/\n|\u2500\u2500 cal_helper.py                     \t# A fake CAL configuration for the BOL currency\n\u251c\u2500\u2500 conftest.py                       \t# Pytest fixtures and device setup\n\u251c\u2500\u2500 test_solana.py                    \t# Functional test cases\n\u251c\u2500\u2500 helper_tool_build_dependencies.py \t# A helper script to pull Exchange and Ethereum applications (needed for Speculos to emulate a swap)\n\u251c\u2500\u2500 helper_tool_clone_dependencies.py \t# A helper script to compile pulled Exchange and Ethereum applications (run after helper_tool_build_dependencies.py INSIDE the Docker)\n\u251c\u2500\u2500 snapshots/                        \t# Ragger UI snapshots\n\u251c\u2500\u2500 snapshots-tmp/                    \t# Temporary snapshot diffs (not tracked in git)\n\u251c\u2500\u2500 requirements.txt                  \t# Python dependencies\n</code></pre>"},{"location":"deps/ledger-secure-sdk/","title":"Ledger Secure SDK","text":""},{"location":"deps/ledger-secure-sdk/#are-you-developing-an-application","title":"Are you developing an application?","text":"<p>If you are developing an application, for a smooth and quick integration: - See the developers\u2019 documentation on the Developer Portal - Go on Discord to chat with developer support and the developer community.</p>"},{"location":"deps/ledger-secure-sdk/#introduction","title":"Introduction","text":"<p>This directory contains the SDK for Nano X, Nano S+, Stax, Apex+ and Flex applications development.</p> <p>This SDK is tightly linked to the Ledger Hardware Wallet OS: BOLOS.</p> <p>Indeed, it allows to interact with <code>syscalls</code> and <code>cxlib</code> functions which are embedded in the OS.</p> <p>Hence you should make sure to use the right SDK version matching your development device OS.</p> <p>You can find below two possibilities to build against the right SDK version.</p>"},{"location":"deps/ledger-secure-sdk/#using-the-docker-image","title":"Using the docker image","text":"<p>The easiest way to build against last device OS is to use the docker image provided by ledger and accessible on ghcr.io.</p> <p>The corresponding GIT repository can be found here. Please have a look at its <code>README.md</code> for information about its usage.</p>"},{"location":"deps/ledger-secure-sdk/#using-the-sdk-directly-advanced-users","title":"Using the SDK directly (advanced users)","text":"<p>Advanced users that have setup the Ledger development environment can use this repository to build apps.</p> <p>But for that, they need to understand how OS and SDK compatibility are tracked. This is done with the <code>API_LEVEL</code> which is defined in <code>Makefile.defines</code>.</p> <p>The <code>API_LEVEL</code> on <code>master</code> branch is kept as the reserved value <code>0</code>.</p> <p>For each released OS there is a corresponding tag in the format <code>&lt;Device&gt;_&lt;os_version&gt;</code>, e.g. <code>NanoX_v2.1.0</code> for the release of the OS version <code>v2.1.0</code> for Nano X device. While on this tag, if you look at the value of the <code>API_LEVEL</code> which is defined in <code>Makefile.defines</code> you will retrieve the OS <code>API_LEVEL</code>.</p> <p>There are also <code>API_LEVEL_&lt;N&gt;</code> branches with <code>API_LEVEL</code> value set to <code>N</code>. Their purpose is to allow cherry-picks of bug fixes and improvements that are merged on <code>master</code> so that they are available when building the apps for the corresponding OS.</p> <p>On these <code>API_LEVEL_&lt;N&gt;</code> branches, there are tags following the format <code>v&lt;N&gt;.&lt;minor&gt;.&lt;patch&gt;</code>, e.g. <code>v1.1.0</code> where <code>N</code> is the <code>API_LEVEL</code>. These tags are used to generate the <code>SDK_VERSION</code> which is available at compile time and allows to track the SDK version used to build an app.</p> <p>The branch <code>API_LEVEL_LNS</code> tracks the sdk for the <code>NanoS_v2.1.0</code>. It's naming does not follow the <code>API_LEVEL_&lt;N&gt;</code> format because it is not a child of the branch <code>API_LEVEL_0</code>.</p> <p>In short, to build an app for an OS, you should: - Retrieve the OS <code>API_LEVEL</code>:     - <code>git checkout &lt;device&gt;_&lt;os_version&gt;</code>     - <code>grep API_LEVEL Makefile.defines | head -n1</code> - Check out the <code>API_LEVEL_&lt;N&gt;</code> branch related to the OS <code>API_LEVEL</code> and make sure it is up to date:     - <code>git checkout API_LEVEL_&lt;N&gt;</code>     - <code>git pull</code>     - The last commit should be tagged with the complete version of the SDK (<code>v&lt;N&gt;.&lt;x&gt;.&lt;y&gt;</code>) - Build the app from your app folder:     - <code>make BOLOS_SDK=&lt;path_to_sdk&gt; TARGET=&lt;target&gt;</code> where <code>target</code> is one of <code>nanox</code>, <code>nanos2</code>, <code>stax</code>, <code>flex</code>, <code>apex_p</code> (<code>nanos2</code> is used for Nano S+ device).</p>"},{"location":"deps/ledger-secure-sdk/#about-api_level-branches","title":"About API_LEVEL branches","text":"<p>This list the main API_LEVEL branches with their purposed (corresponding OS) and state if they should still be patched or not (OS not \u201cactive\u201d anymore).</p> <p>The full mapping of API_LEVEL branches, including OS release candidates, is available here.</p> Name Related OS Active LNS  nanos_2.1.0 :heavy_check_mark: 1 nanox_2.1.0  nanos+_1.1.0 :x: 5 nanox_2.2.{0, 1, 2, 3}  nanos+ 1.1.1 :x: 8 stax_1.0.0 :x: 10 stax_1.1.0 :x: 11 stax_1.2.0  stax_1.2.1 :x: 13 stax_1.3.0 :x: 15 stax_1.4.0 :x: 18 nanos+_1.2.0 :x: 19 flex_1.0.0  flex_1.0.1  :x: 21 stax_1.5.0  flex_1.1.0  flex_1.1.1  :x: 22 nanox_2.4.1  nanos+_1.3.1  stax_1.6.1  flex_1.2.1  nanox_2.4.2  nanos+_1.3.2  stax_1.6.2  flex_1.2.2  :x: 24 nanox_2.5.1  nanos+_1.4.1  stax_1.8.1  flex_1.4.1  :x: 25 apex_p_1.0.4  nanox_2.6.0  nanos+_1.5.0  stax_1.9.0  flex_1.5.0  :heavy_check_mark:"},{"location":"deps/ledger-secure-sdk/#cherry-picking-process","title":"Cherry-picking process:","text":"<ul> <li> <p>Fetch last changes from remote: <code>git fetch --all</code></p> </li> <li> <p>Create a new branch to hold your cherry-picks: <code>git checkout origin/API_LEVEL_X -b mybranch</code></p> </li> <li> <p>Cherry-pick your commits: <code>git cherry-pick -x commit_sha1</code> (the -x is useful to track the original commit of a cherry-pick).</p> </li> <li> <p>Push your branch: <code>git push origin mybranch</code></p> </li> <li> <p>Create a PR and indicate in it the PR where your cherry-pick where reviewed first.</p> </li> </ul>"},{"location":"deps/ledger-secure-sdk/#contributing","title":"Contributing","text":""},{"location":"deps/ledger-secure-sdk/#pre-commit","title":"Pre-commit","text":"<p>This repository uses pre-commit to identify simple programming issues at the time of code check-in.</p> <p>To enable pre-commit in your development environment:</p> <ol> <li> <p>Install pre-commit:</p> <pre><code>pip install pre-commit\n</code></pre> </li> <li> <p>Add pre-commit hooks</p> <pre><code>pre-commit install --hook-type pre-commit\npre-commit install --hook-type commit-msg\n</code></pre> </li> </ol>"},{"location":"deps/ledger-secure-sdk/#documentation","title":"Documentation","text":"<p>HTML documentation can be generated by typing:</p> <ul> <li>For Stax:</li> </ul> <p><code>make doc TARGET=stax</code></p> <ul> <li>For Nano X or Nano S+:</li> </ul> <p><code>make doc TARGET=nano</code></p> <p>from root directory</p> <p>The resulting documentation can be found in <code>build/doc/html/index.html</code></p> <p>If you have not already installed Doxygen, you can do it (on Linux-Ubuntu) with:</p> <pre><code>sudo apt-get install doxygen doxygen-doc graphviz\n</code></pre>"},{"location":"deps/ledger-secure-sdk/fuzzing/","title":"Fuzzing","text":""},{"location":"deps/ledger-secure-sdk/fuzzing/#manual-usage-based-on-ledger-container","title":"Manual usage based on Ledger container","text":""},{"location":"deps/ledger-secure-sdk/fuzzing/#about-fuzzing-framework","title":"About Fuzzing Framework","text":"<p>The code is divided into the following folders:</p> <pre><code>\u251c\u2500\u2500 fuzzing\n\u2502   \u251c\u2500\u2500 build\n\u2502   \u2502   \u251c\u2500\u2500 ...\n\u2502   \u2502   \u2514\u2500\u2500 generated_glyphs   #  generated glyphs\n\u2502   \u251c\u2500\u2500 extra                  #  .cmake files for building SDK's function harness\n\u2502   \u251c\u2500\u2500 harness                #  libFuzzer .c files for harness\n\u2502   \u2502   \u2514\u2500\u2500 fuzz_{}/           #  Optional folders for corpus of each harness [with the same name as the harness]\n\u2502   \u251c\u2500\u2500 libs                   #  .cmake files for building SDK libraries\n\u2502   \u251c\u2500\u2500 macros\n\u2502   \u2502   \u251c\u2500\u2500 Makefile           #  Makefile used to expose the macros used when fuzzing the SDK\n\u2502   \u2502   \u2514\u2500\u2500 macros.cmake       #  creates an INTERFACE for using macros in cmake targets\n\u2502   \u2502   \u2514\u2500\u2500 add_macros.txt     #  macro list to add in SDK fuzzer compilation process\n\u2502   \u2502   \u2514\u2500\u2500 exclude_macros.txt #  macro list to exclude from the SDK fuzzer compilation process\n\u2502   \u251c\u2500\u2500 mock\n\u2502   \u2502   \u251c\u2500\u2500 custom             #  Custom mock implementations for specific use cases (folder name must appear before 'generated' to override __weak__ functions)\n\u2502   \u2502   \u251c\u2500\u2500 generated          #  automatically generated mock functions from src/syscalls.c\n\u2502   \u2502   \u2514\u2500\u2500 mock.cmake         #  .cmake file for building mock functions\n\u2502   \u251c\u2500\u2500 out                    #  Fuzzing output files\n\u2502   \u251c\u2500\u2500 CMakeLists.txt         #  .cmake file that builds SDK Fuzzers and exposes an INTERFACE for SDK libs for fuzzing APPs\n\u2502   \u251c\u2500\u2500 local_run.sh           #  Script for building and running fuzzers.\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500 README.md\n</code></pre>"},{"location":"deps/ledger-secure-sdk/fuzzing/#preparation","title":"Preparation","text":"<p>The fuzzer can run from the docker <code>ledger-app-dev-tools</code>. You can download it from the <code>ghcr.io</code> docker repository:</p> <pre><code>sudo docker pull ghcr.io/ledgerhq/ledger-app-builder/ledger-app-dev-tools\n</code></pre> <p>You can then enter this development environment by executing the following command from the repository root directory:</p> <pre><code>docker run --rm -ti -v \"$(realpath .):/app\" ghcr.io/ledgerhq/ledger-app-builder/ledger-app-dev-tools\n</code></pre> <pre><code>export BOLOS_SDK=/app\n\ncd fuzzing # You must run it from the fuzzing folder\n\n./local_run.sh --build=1 --fuzzer=build/fuzz_bip32 --j=4 --run-fuzzer=1 --compute-coverage=1 --BOLOS_SDK=${BOLOS_SDK}\n</code></pre>"},{"location":"deps/ledger-secure-sdk/fuzzing/#about-local_runsh","title":"About local_run.sh","text":"Parameter Type Description <code>--BOLOS_SDK</code> <code>PATH TO BOLOS SDK</code> Required. Path to the BOLOS SDK <code>--build</code> <code>bool</code> Optional. Whether to build the project (default: 0) <code>--fuzzer</code> <code>PATH</code> Required. Path to the fuzzer binary <code>--compute-coverage</code> <code>bool</code> Optional. Whether to compute coverage after fuzzing (default: 0) <code>--run-fuzzer</code> <code>bool</code> Optional. Whether to run or not the fuzzer (default: 0) <code>--run-crash</code> <code>FILENAME</code> Optional. Run the fuzzer on a specific crash input file (default: 0) <code>--sanitizer</code> <code>address or memory</code> Optional. Compile fuzzer with sanitizer (default: address) <code>--j</code> <code>int</code> Optional. Number of parallel jobs/CPUs for build and fuzzing (default: 1) <code>--help</code> Optional. Display help message"},{"location":"deps/ledger-secure-sdk/fuzzing/#writing-your-harness","title":"Writing your Harness","text":"<p>When writing your harness, keep the following points in mind:</p> <ul> <li>An SDK's interface for compilation is provided via the target <code>secure_sdk</code> in CMakeLists.txt</li> <li>If you are running it for the first time, consider using the script <code>local_run</code> from inside the   Docker container using the flag build=1, if you need to manually   add/remove macros you can then do it using the files macros/add_macros.txt or   macros/exclude_macros.txt and rerunning it, or directly change the generated macros/generated/macros.txt.</li> <li>A typical harness looks like this:</li> </ul> <pre><code>int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n  if (sigsetjmp(fuzz_exit_jump_ctx.jmp_buf, 1)) return 0;\n\n  ### harness code ###\n\n  return 0;\n}\n</code></pre> <p>This allows a return point when the <code>os_sched_exit()</code> function is mocked.</p> <ul> <li>To provide an SDK interface, we automatically generate syscall mock functions located in   <code>SECURE_SDK_PATH/fuzzing/mock/generated/generated_syscalls.c</code>, if you need a more specific mock,   you can define it in <code>APP_PATH/fuzzing/mock</code> with the same name and without the WEAK attribute.</li> </ul>"},{"location":"deps/ledger-secure-sdk/fuzzing/#adding-an-initial-corpus","title":"Adding an initial Corpus","text":"<pre><code>\u251c\u2500\u2500 fuzzing\n\u2502   \u251c\u2500\u2500 harness              # libFuzzer .c files for harness\n\u2502   \u2502   \u2514\u2500\u2500 fuzz_{}/         # Optional folders for corpus of each harness [with the same name as the harness]\n</code></pre> <p>To add an initial corpus for a specific harness, create a folder with the same name of the harness inside <code>fuzzing/harness</code> with the binary input files.</p> <p>The <code>local_run.sh</code> script will move them to the corpus before the fuzzing. If committed those folders will also be used by ClusterFuzz in CI.</p>"},{"location":"deps/ledger-secure-sdk/fuzzing/#manual-compilation","title":"Manual compilation","text":"<p>Once in the container, go into the <code>fuzzing</code> folder to compile the fuzzer:</p> <pre><code># Install missing dependencies\napt update &amp;&amp; apt install -y libclang-rt-dev\n\n# cmake initialization\ncmake -S . -B build -DCMAKE_C_COMPILER=clang -DSANITIZER=address -G Ninja\n\n# Fuzzer compilation\ncmake --build build\n</code></pre> <p>One can still use his own modified <code>ledgere-secure-sdk</code>. If it doesn't contain a .target, you can pass it in the compilation parameters: <pre><code>cmake -S . -B build -DCMAKE_C_COMPILER=clang -DSANITIZER=address -G Ninja -DTARGET=stax\n</code></pre></p>"},{"location":"deps/ledger-secure-sdk/fuzzing/#run","title":"Run","text":"<pre><code>./build/fuzz_apdu_parser\n./build/fuzz_base58\n./build/fuzz_bip32\n./build/fuzz_qrcodegen\n./build/fuzz_alloc\n./build/fuzz_nfc_ndef\n</code></pre>"},{"location":"deps/ledger-secure-sdk/lib_nbgl/","title":"NBGL library","text":"<p>Graphic library for Stax</p>"},{"location":"deps/ledger-secure-sdk/lib_nbgl/serialization/","title":"Index","text":""},{"location":"deps/ledger-secure-sdk/lib_nbgl/serialization/#nbgl-serializationdeserialization-library","title":"NBGL serialization/deserialization library","text":""},{"location":"deps/ledger-secure-sdk/lib_nbgl/serialization/#usage","title":"Usage","text":"<p>Deserialize raw bytes into an Nbgl event: <pre><code>&gt;&gt;&gt; from nbgl_lib import deserialize_nbgl_bytes\n&gt;&gt;&gt; data = bytes.fromhex(\"00010501f403e800ff003201000301020403015465737420627574746f6e00\")\n&gt;&gt;&gt; nbgl_event = deserialize_nbgl_bytes(data)\n&gt;&gt;&gt; nbgl_event\nNbglDrawObjectEvent(obj=NbglButton(area=NbglArea(width=255, height=50, x0=500, y0=1000, background_color=&lt;NbglColor.DARK_GRAY: 1&gt;, bpp=&lt;NbglBpp.BPP_1: 0&gt;), inner_color=&lt;NbglColor.WHITE: 3&gt;, border_color=&lt;NbglColor.DARK_GRAY: 1&gt;, foreground_color=&lt;NbglColor.LIGHT_GRAY: 2&gt;, radius=&lt;NbglRadius.RADIUS_40_PIXELS: 4&gt;, font_id=&lt;NbglFontId.BAGL_FONT_HM_ALPHA_MONO_MEDIUM_32px: 3&gt;, localized=True, text='Test button'))\n</code></pre></p> <p>Serialize a Nbgl event into a json-like dict: <pre><code>&gt;&gt;&gt; from nbgl_lib import serialize_nbgl_json\n&gt;&gt;&gt; serialize_nbgl_json(nbgl_event)\n{'event': 'NBGL_DRAW_OBJ', 'obj': {'type': 'BUTTON', 'content': {'area': {'width': 255, 'height': 50, 'x0': 500, 'y0': 1000, 'background_color': 'DARK_GRAY', 'bpp': 'BPP_1'}, 'inner_color': 'WHITE', 'border_color': 'DARK_GRAY', 'foreground_color': 'LIGHT_GRAY', 'radius': 'RADIUS_40_PIXELS', 'font_id': 'BAGL_FONT_HM_ALPHA_MONO_MEDIUM_32px', 'localized': True, 'text': 'Test button'}}}\n</code></pre></p> <p>Deserialize json-like dict into an Nbgl event:</p> <pre><code>&gt;&gt;&gt; from nbgl_lib import deserialize_nbgl_json\n&gt;&gt;&gt; deserialize_nbgl_json({'event': 'NBGL_DRAW_OBJ', 'obj': {'type': 'BUTTON', 'content': {'area': {'width': 255, 'height': 50, 'x0': 500, 'y0': 1000, 'background_color': 'DARK_GRAY', 'bpp': 'BPP_1'}, 'inner_color': 'WHITE', 'border_color': 'DARK_GRAY', 'foreground_color': 'LIGHT_GRAY', 'radius': 'RADIUS_40_PIXELS', 'font_id': 'BAGL_FONT_HM_ALPHA_MONO_MEDIUM_32px', 'localized': True, 'text': 'Test button'}}})\nNbglDrawObjectEvent(obj=NbglButton(area=NbglArea(width=255, height=50, x0=500, y0=1000, background_color=&lt;NbglColor.DARK_GRAY: 1&gt;, bpp=&lt;NbglBpp.BPP_1: 0&gt;), inner_color=&lt;NbglColor.WHITE: 3&gt;, border_color=&lt;NbglColor.DARK_GRAY: 1&gt;, foreground_color=&lt;NbglColor.LIGHT_GRAY: 2&gt;, radius=&lt;NbglRadius.RADIUS_40_PIXELS: 4&gt;, font_id=&lt;NbglFontId.BAGL_FONT_HM_ALPHA_MONO_MEDIUM_32px: 3&gt;, localized=True, text='Test button'))\n</code></pre>"},{"location":"deps/ledger-secure-sdk/lib_nbgl/serialization/#tests","title":"Tests","text":"<ul> <li><code>generate_data_test.c</code> generates reference data for deserialization testing.</li> <li><code>test_bytes_deserialize.py</code> deserializes the reference data and inspect the result.</li> <li><code>test_json_ser_deser.py</code> tests json serialization and deserialization.</li> </ul> <p>To generate reference data and run tests:</p> <pre><code>make run_test\n</code></pre>"},{"location":"deps/ledger-secure-sdk/tests/screenshots/","title":"Screenshots generation","text":""},{"location":"deps/ledger-secure-sdk/tests/screenshots/#prerequisite","title":"Prerequisite","text":"<p>TBC</p>"},{"location":"deps/ledger-secure-sdk/tests/screenshots/#overview","title":"Overview","text":"<p>The goal of this mechanism is to generate screenshots of usual Applications scenarios.</p> <p>It can be used for any product (Stax, Flex, NanoX, NanoS+)</p>"},{"location":"deps/ledger-secure-sdk/tests/screenshots/#launch-screenshots-generation","title":"Launch screenshots generation","text":"<p>The screenshots generator can be built and launched in the same command, for a given product</p> <pre><code>make &lt;product&gt;_screenshots\n</code></pre> <p>where <code>&lt;product&gt;</code> can be:</p> <ul> <li><code>flex</code></li> <li><code>stax</code></li> <li><code>nanox</code></li> <li><code>nanosp</code></li> <li><code>apex_p</code></li> </ul> <p>so for example to generate screenshots for Flex:</p> <pre><code>make flex_screenshots\n</code></pre> <p>The result can be found in <code>build/&lt;product&gt;/screenshots</code></p>"},{"location":"deps/ledger-secure-sdk/tests/screenshots/#clean","title":"Clean","text":"<p>The environment can be cleaned-up with:</p> <pre><code>make &lt;product&gt;_clean\n</code></pre>"},{"location":"deps/ledger-secure-sdk/tests/screenshots/#regenerate-golden-samples","title":"(Re)Generate golden samples","text":"<p>The golden samples of screenshots can be (re)regenerated, if needed, with:</p> <pre><code>make &lt;product&gt;_golden\n</code></pre>"},{"location":"deps/ledger-secure-sdk/unit-tests/app_storage/","title":"Unit tests","text":""},{"location":"deps/ledger-secure-sdk/unit-tests/app_storage/#prerequisite","title":"Prerequisite","text":"<p>Be sure to have installed:</p> <ul> <li>CMake &gt;= 3.10</li> <li>CMocka &gt;= 1.1.5</li> </ul> <p>and for code coverage generation:</p> <ul> <li>lcov &gt;= 1.14</li> </ul>"},{"location":"deps/ledger-secure-sdk/unit-tests/app_storage/#overview","title":"Overview","text":"<p>In <code>unit-tests/app_storage</code> folder, compile with:</p> <pre><code>cmake -Bbuild -H. &amp;&amp; make -C build\n</code></pre> <p>and run tests with:</p> <pre><code>CTEST_OUTPUT_ON_FAILURE=1 make -C build test\n</code></pre>"},{"location":"deps/ledger-secure-sdk/unit-tests/app_storage/#generate-code-coverage","title":"Generate code coverage","text":"<p>Just execute in <code>unit-tests</code> folder</p> <pre><code>../gen_coverage.sh\n</code></pre> <p>it will output <code>coverage.total</code> and <code>coverage/</code> folder with HTML details (in <code>coverage/index.html</code>).</p>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_alloc/","title":"Dynamic Allocator Unit tests","text":""},{"location":"deps/ledger-secure-sdk/unit-tests/lib_alloc/#prerequisite","title":"Prerequisite","text":"<p>Be sure to have installed:</p> <ul> <li>CMake &gt;= 3.10</li> <li>CMocka &gt;= 1.1.5</li> </ul> <p>and for code coverage generation:</p> <ul> <li>lcov &gt;= 1.14</li> </ul>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_alloc/#overview","title":"Overview","text":"<p>In <code>unit-tests</code> folder, compile with:</p> <pre><code>cmake -Bbuild -H. &amp;&amp; make -C build\n</code></pre> <p>and run tests with:</p> <pre><code>CTEST_OUTPUT_ON_FAILURE=1 make -C build test\n</code></pre>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_alloc/#generate-code-coverage","title":"Generate code coverage","text":"<p>Just execute in <code>unit-tests</code> folder</p> <pre><code>../gen_coverage.sh\n</code></pre> <p>it will output <code>coverage.total</code> and <code>coverage/</code> folder with HTML details (in <code>coverage/index.html</code>).</p>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_nbgl/","title":"Unit tests","text":""},{"location":"deps/ledger-secure-sdk/unit-tests/lib_nbgl/#prerequisite","title":"Prerequisite","text":"<p>Be sure to have installed:</p> <ul> <li>CMake &gt;= 3.10</li> <li>CMocka &gt;= 1.1.5</li> </ul> <p>and for code coverage generation:</p> <ul> <li>lcov &gt;= 1.14</li> </ul>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_nbgl/#overview","title":"Overview","text":""},{"location":"deps/ledger-secure-sdk/unit-tests/lib_nbgl/#for-stax","title":"For Stax","text":"<p>In <code>unit-tests/lib_nbgl</code> folder, compile with:</p> <pre><code>STAX=1 cmake -Bbuild -H. &amp;&amp; make -C build\n</code></pre> <p>and run tests with:</p> <pre><code>CTEST_OUTPUT_ON_FAILURE=1 make -C build test\n</code></pre>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_nbgl/#for-nanos","title":"For Nanos","text":"<p>In <code>unit-tests</code> folder, compile with:</p> <pre><code>cmake -Bbuild -H. &amp;&amp; make -C build\n</code></pre> <p>and run tests with:</p> <pre><code>CTEST_OUTPUT_ON_FAILURE=1 make -C build test\n</code></pre>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_nbgl/#generate-code-coverage","title":"Generate code coverage","text":"<p>Just execute in <code>unit-tests</code> folder</p> <pre><code>../gen_coverage.sh\n</code></pre> <p>it will output <code>coverage.total</code> and <code>coverage/</code> folder with HTML details (in <code>coverage/index.html</code>).</p>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_standard_app/","title":"Unit tests","text":""},{"location":"deps/ledger-secure-sdk/unit-tests/lib_standard_app/#prerequisite","title":"Prerequisite","text":"<p>Be sure to have installed:</p> <ul> <li>CMake &gt;= 3.10</li> <li>CMocka &gt;= 1.1.5</li> </ul> <p>and for code coverage generation:</p> <ul> <li>lcov &gt;= 1.14</li> </ul>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_standard_app/#overview","title":"Overview","text":"<p>In <code>unit-tests/lib_standard_app</code> folder, compile with</p> <pre><code>cmake -Bbuild -H. &amp;&amp; make -C build\n</code></pre> <p>and run tests with</p> <pre><code>CTEST_OUTPUT_ON_FAILURE=1 make -C build test\n</code></pre>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_standard_app/#generate-code-coverage","title":"Generate code coverage","text":"<p>Just execute in <code>unit-tests</code> folder</p> <pre><code>../gen_coverage.sh\n</code></pre> <p>it will output <code>coverage.total</code> and <code>coverage/</code> folder with HTML details (in <code>coverage/index.html</code>).</p>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_tlv/","title":"Unit tests","text":""},{"location":"deps/ledger-secure-sdk/unit-tests/lib_tlv/#prerequisite","title":"Prerequisite","text":"<p>Be sure to have installed:</p> <ul> <li>CMake &gt;= 3.10</li> <li>CMocka &gt;= 1.1.5</li> </ul> <p>and for code coverage generation:</p> <ul> <li>lcov &gt;= 1.14</li> </ul>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_tlv/#overview","title":"Overview","text":"<p>In <code>unit-tests/lib_tlv</code> folder, compile with:</p> <pre><code>cmake -Bbuild -H. &amp;&amp; make -C build\n</code></pre> <p>and run tests with:</p> <pre><code>CTEST_OUTPUT_ON_FAILURE=1 make -C build test\n</code></pre>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_tlv/#generate-code-coverage","title":"Generate code coverage","text":"<p>Just execute in <code>unit-tests</code> folder</p> <pre><code>../gen_coverage.sh\n</code></pre> <p>it will output <code>coverage.total</code> and <code>coverage/</code> folder with HTML details (in <code>coverage/index.html</code>).</p>"},{"location":"deps/ledger-secure-sdk/unit-tests/print/","title":"PRINTF &amp; snprintf Unit tests","text":""},{"location":"deps/ledger-secure-sdk/unit-tests/print/#prerequisite","title":"Prerequisite","text":"<p>Be sure to have installed:</p> <ul> <li>CMake &gt;= 3.10</li> <li>CMocka &gt;= 1.1.5</li> </ul> <p>and for code coverage generation:</p> <ul> <li>lcov &gt;= 1.14</li> </ul>"},{"location":"deps/ledger-secure-sdk/unit-tests/print/#overview","title":"Overview","text":"<p>In <code>unit-tests</code> folder, compile with:</p> <pre><code>cmake -Bbuild -H. &amp;&amp; make -C build\n</code></pre> <p>and run tests with:</p> <pre><code>CTEST_OUTPUT_ON_FAILURE=1 make -C build test\n</code></pre>"},{"location":"deps/ledger-secure-sdk/unit-tests/print/#generate-code-coverage","title":"Generate code coverage","text":"<p>Just execute in <code>unit-tests</code> folder</p> <pre><code>../gen_coverage.sh\n</code></pre> <p>it will output <code>coverage.total</code> and <code>coverage/</code> folder with HTML details (in <code>coverage/index.html</code>).</p>"},{"location":"technical_information/","title":"Technical Information","text":"<p>Please find in this section technical information helpful for understanding the SWAP feature and for adding compatibility with it in your own Coin Application.</p> <p>Only technical information specific to the SWAP feature is provided here.</p>"},{"location":"technical_information/bss/","title":"BSS safety in coin applications","text":"<p>When a coin application is started by Exchange through <code>os_lib_call</code>, the BSS section of the application is not private. To save RAM, Exchange shares this memory space with the coin application.  </p> <p>Because of this design, writing into the BSS at the wrong time can corrupt Exchange\u2019s state. Strict rules are enforced to guarantee safety.</p>"},{"location":"technical_information/bss/#rules-for-bss-usage","title":"Rules for BSS usage","text":""},{"location":"technical_information/bss/#forbidden-in","title":"Forbidden in:","text":"<ul> <li><code>swap_handle_check_address()</code></li> <li><code>swap_handle_get_printable_amount()</code></li> </ul> <p>Exchange protects its memory integrity by hashing the BSS section before and after these calls. Any modification results in an error being raised. Depending on where the application writes, this corruption may or may not be detected.</p>"},{"location":"technical_information/bss/#allowed-and-expected-in","title":"Allowed and expected in:","text":"<ul> <li><code>swap_copy_transaction_parameters()</code> (final signing phase)</li> </ul> <p>Exchange is designed to wipe and reinitialize memory at this stage, so the BSS can safely be used.</p>"},{"location":"technical_information/bss/#consequences-of-unsafe-writes","title":"Consequences of unsafe writes","text":""},{"location":"technical_information/bss/#during-check_address-or-format_amount","title":"During <code>CHECK_ADDRESS</code> or <code>FORMAT_AMOUNT</code>:","text":"<ul> <li>Writing to BSS will trigger an integrity mismatch and return an error.  </li> <li>In some cases, writes may go undetected but still lead to undefined behavior later.</li> </ul>"},{"location":"technical_information/bss/#during-sign_transaction","title":"During <code>SIGN_TRANSACTION</code>:","text":"<ul> <li>Writes are allowed because Exchange performs a full reset of the shared memory afterwards.</li> </ul>"},{"location":"technical_information/bss/#best-practices","title":"Best practices","text":"<ul> <li> <p>Treat the BSS as read-only during <code>CHECK_ADDRESS</code> and <code>FORMAT_AMOUNT</code>.   Do not use global variables, static buffers, or any memory that lives in the BSS section.</p> </li> <li> <p>Use the stack for temporary values.   Handlers in these phases are simple:  </p> </li> <li><code>CHECK_ADDRESS</code> \u2192 only validate the provided address.  </li> <li><code>FORMAT_AMOUNT</code> \u2192 only format and return the amount string.   These operations can be done entirely with stack-based variables.</li> </ul> <p>By following these rules, coin applications remain compatible with Exchange and avoid hard-to-diagnose memory corruption issues.</p>"},{"location":"technical_information/cal/","title":"Crypto Asset List (CAL)","text":"<p>The Crypto Asset List is designed to address two issues:</p> <ul> <li>The Exchange application does not know which application to call to handle a given currency.</li> <li>The Coin application may not have all the data required to handle a given currency.</li> </ul> <p>These issues are solved by using the CAL to provide trusted information to the Exchange application.</p>"},{"location":"technical_information/cal/#the-cal-signature","title":"The CAL signature","text":"<p>The CAL data is stored on an HSM alongside its signature.</p> <p>The signature is checked by the Exchange application upon reception of CAL data to ensure that the data is legitimate.</p> <p>To allow testing with dynamic data, the Exchange application can be compiled with the <code>TEST_PUBLIC_KEY=1</code> flag to accept a false Ledger HSM key. The resulting application will not work in production but is useful in the test framework.</p>"},{"location":"technical_information/cal/#the-coin-configuration-format","title":"The coin configuration format","text":"<p>A coin configuration for a currency contains the following elements:</p> Bytes Description 1 byte Coin configuration length of the FROM coin. The coin configuration is made of the ticker, appname, and subconf 1 byte Ticker name length N N bytes Ticker name of this the coin configuration. The ticker has to be the same as the FROM ticker 1 byte Application name length M M bytes Name of the application that can handle this currency 1 byte Sub coin configuration length R R bytes Sub coin configuration, used for tokens to specify an app the subticker and the decimals S bytes Signature of the coin configuration by the Ledger key in DER format, curve secp256k1 hashfunc sha256 1 byte Packed derivation path length T T bytes Packed derivation path used for the FROM coin"},{"location":"technical_information/cal/#the-subconfiguration","title":"The subconfiguration","text":"<p>The <code>subconfiguration</code> part is optional and is often used only when handling tokens.</p> <p>Its content is application-specific. The byte array will be passed as a pointer to the handlers in the coin application. For more information about the handlers, please refer to the corresponding section: Coin Application API.</p> <p>A standard subconfiguration exists, composed of <code>ticker + decimals</code>. This is the one used by most of our applications when handling tokens (for example, Ethereum and Solana).</p> <p>The Ragger tool provides utilities to craft coin configurations both without and with the standard subconfiguration.</p> <p>As an example, here is the crafting of the coin configuration for Solana in our tests:</p> <p>app-solana/tests/application_client/solana_utils.py <pre><code>from ragger.utils import create_currency_config\nfrom ragger.bip import pack_derivation_path\n\n### Proposed Solana derivation paths for tests ###\n\nSOL_PACKED_DERIVATION_PATH      = pack_derivation_path(\"m/44'/501'/12345'\")\nSOL_PACKED_DERIVATION_PATH_2    = pack_derivation_path(\"m/44'/501'/0'/0'\")\n\n### Package this currency configuration in exchange format ###\n\n# Simple native currency configuration: Ticker + Appname\nSOL_CONF = create_currency_config(\"SOL\", \"Solana\")\n\n# Standard coin configuration for a token: Ticker + Appname + (Ticker + decimal)\nJUP_CONF = create_currency_config(\"JUP\", \"Solana\", (\"JUP\", 6))\nJUP_PACKED_DERIVATION_PATH = SOL_PACKED_DERIVATION_PATH\n\nSOL_USDC_CONF = create_currency_config(\"USDC\", \"Solana\", (\"USDC\", 6))\nSOL_USDC_PACKED_DERIVATION_PATH = SOL_PACKED_DERIVATION_PATH\n\nGORK_CONF = create_currency_config(\"GORK\", \"Solana\", (\"GORK\", 6))\nGORK_PACKED_DERIVATION_PATH = SOL_PACKED_DERIVATION_PATH\n</code></pre></p> <p>tests/swap/cal_helper.py <pre><code># Solana and Solana tokens\nSOL_CURRENCY_CONFIGURATION = CurrencyConfiguration(ticker=\"SOL\", conf=SOL.SOL_CONF, packed_derivation_path=SOL.SOL_PACKED_DERIVATION_PATH)\nJUP_CURRENCY_CONFIGURATION = CurrencyConfiguration(ticker=\"JUP\", conf=SOL.JUP_CONF, packed_derivation_path=SOL.JUP_PACKED_DERIVATION_PATH)\nSOL_USDC_CURRENCY_CONFIGURATION = CurrencyConfiguration(ticker=\"USDC\", conf=SOL.SOL_USDC_CONF, packed_derivation_path=SOL.SOL_USDC_PACKED_DERIVATION_PATH)\nGORK_CURRENCY_CONFIGURATION = CurrencyConfiguration(ticker=\"GORK\", conf=SOL.GORK_CONF, packed_derivation_path=SOL.GORK_PACKED_DERIVATION_PATH)\n</code></pre></p>"},{"location":"technical_information/dale/","title":"The DALE tool","text":"<p>The Dale tool can be used to translate Exchange APDUs and RAPDUs into clear text.</p> <p>It is useful for diagnosing SWAP errors and better understanding what went wrong.</p> <p>To use it, follow the README procedure in the Dale repository:</p> <p>https://github.com/LedgerHQ/dale</p>"},{"location":"technical_information/diagram/","title":"Sequence diagram of a SWAP","text":"<p>This diagram showcases:</p> <ul> <li>The APDU and RAPDU exchanged between the Ledger Wallet and the Exchange application during a SWAP.</li> <li>The <code>os_lib_calls</code> commands made by the Exchange application to the involved Coin applications. </li> </ul> <p>Please look at the protocol documentation to know more about how the APDUs content.</p> <pre><code>sequenceDiagram\n    participant LL as Ledger Wallet\n    participant EA as Exchange App\n    participant TOCA as TO Coin App\n    participant FRCA as FROM Coin App\n    participant DS as Device Screen\n\n    LL-&gt;&gt;EA: START_NEW_TRANSACTION&lt;br/&gt;(0x03)\n    activate EA\n    EA--&gt;&gt;EA: Create a nonce for the transaction\n    EA--&gt;&gt;LL: Device Transaction ID (nonce)\n\n    LL-&gt;&gt;EA: SET_PARTNER_KEY&lt;br/&gt;(0x04)\n    EA--&gt;&gt;EA: Set the credentials of the exchange partner\n    EA--&gt;&gt;LL: return\n\n    LL-&gt;&gt;EA: CHECK_PARTNER&lt;br/&gt;(0x05)\n    EA--&gt;&gt;EA: Check that the credentials of the exchange&lt;br/&gt;partner are signed by the Ledger key\n    EA--&gt;&gt;LL: return\n\n    LL-&gt;&gt;EA: PROCESS_TRANSACTION_RESPONSE&lt;br/&gt;(0x06)\n    EA--&gt;&gt;EA: Receive and parse the transaction&lt;br/&gt;proposal from the exchange partner\n    EA--&gt;&gt;LL: return\n\n    LL-&gt;&gt;EA: CHECK_TRANSACTION_SIGNATURE&lt;br/&gt;(0x07)\n    EA--&gt;&gt;EA: Check that the transaction proposal&lt;br/&gt;is signed by the exchange partner\n    EA--&gt;&gt;LL: return\n\n    LL-&gt;&gt;EA: CHECK_PAYOUT_ADDRESS&lt;br/&gt;(0x08)\n    EA--&gt;&gt;TOCA: CHECK_ADDRESS os_lib_call()\n    activate TOCA\n    TOCA--&gt;&gt;TOCA: Check that the [payout] address is owned by the device\n    TOCA--&gt;&gt;EA: os_lib_end(): Result\n    deactivate TOCA\n    EA-&gt;&gt;TOCA: GET_PRINTABLE_AMOUNT os_lib_call()\n    activate TOCA\n    TOCA--&gt;&gt;TOCA: Format the receiving amount\n    TOCA--&gt;&gt;EA: os_lib_end(): Formatted amount\n    deactivate TOCA\n    EA--&gt;&gt;LL: return\n\n    LL-&gt;&gt;EA: CHECK_REFUND_ADDRESS_NO_DISPLAY&lt;br/&gt;(0x0C)\n    EA-&gt;&gt;FRCA: CHECK_ADDRESS os_lib_call()\n    activate FRCA\n    FRCA--&gt;&gt;FRCA: Check that the [refund] address belongs to the device\n    FRCA--&gt;&gt;EA: os_lib_end(): Result\n    deactivate FRCA\n    EA-&gt;&gt;FRCA: GET_PRINTABLE_AMOUNT os_lib_call()\n    activate FRCA\n    FRCA--&gt;&gt;FRCA: Format the sending amount\n    FRCA--&gt;&gt;EA: os_lib_end(): Formatted amount\n    deactivate FRCA\n    EA-&gt;&gt;FRCA: GET_PRINTABLE_AMOUNT os_lib_call()\n    activate FRCA\n    FRCA--&gt;&gt;FRCA: Format the fees amount\n    FRCA--&gt;&gt;EA: os_lib_end(): Formatted amount\n    deactivate FRCA\n    EA--&gt;&gt;LL: return\n\n    LL-&gt;&gt;EA: PROMPT_UI_DISPLAY&lt;br/&gt;(0x0F)\n    EA-&gt;&gt;DS: Request UI validation\n    activate DS\n    DS--&gt;&gt;DS: Display all the transaction data&lt;br/&gt;ask user to confirm\n    DS--&gt;&gt;EA: User confirmation\n    deactivate DS\n    EA--&gt;&gt;LL: return\n\n    LL-&gt;&gt;EA: START_SIGNING_TRANSACTION&lt;br/&gt;(0x0A)\n    EA--&gt;&gt;LL: Ok\n    EA-&gt;&gt;FRCA: SIGN_TRANSACTION os_lib_call()\n    activate FRCA\n    deactivate EA\n    FRCA--&gt;&gt;FRCA: Save data validated by the user\n    LL-&gt;&gt;FRCA: Sign transaction request\n    FRCA--&gt;&gt;FRCA: Check that the data to sign is the same&lt;br/&gt;as the data validated by the user + Sign\n    FRCA--&gt;&gt;LL: Signed transaction\n    FRCA--&gt;&gt;EA: os_lib_end()\n    deactivate FRCA\n    activate EA\n    EA--&gt;&gt;EA: Save last cycle data:&lt;br/&gt;Coin appname + sign status\n    EA--&gt;&gt;EA: Check if previous cycle\n    EA--&gt;&gt;DS: if previous cycle\n    activate DS\n    DS--&gt;&gt;DS: display sign status\n    DS--&gt;&gt;EA: \n    deactivate DS\n    deactivate EA</code></pre> <p>The FUND and SELL flows are not described as they are only subsets of the SWAP flow.</p>"},{"location":"technical_information/fund_and_sell/","title":"FUND and SELL flows","text":"<p>The SWAP feature refers to trading an amount of a FROM crypto against an amount of a TO crypto.</p> <p>The FUND feature refers to sending an amount of a FROM crypto to an external account (for example, funding a debit card).</p> <p>The SELL feature refers to trading an amount of a FROM crypto against a FIAT amount.</p> <p>From the perspective of the library application, the FUND and SELL specificities are irrelevant and have no difference with the SWAP feature. They only impact the APDUs exchanged between Ledger Wallet and the Exchange application.  </p> <p>In the test framework, this behavior is entirely handled by the ExchangeTestRunner.</p>"},{"location":"technical_information/protocol/","title":"EXCHANGE application protocol API","text":"<p>Communication is done through a series of request-response exchanges (APDU / RAPDU).</p> <p>Please look at the sequence diagram to know more about the APDUs used here.</p>"},{"location":"technical_information/protocol/#request","title":"Request:","text":"Bytes Description 1 byte CLASS (constant 0xE0) 1 byte COMMAND to run 1 byte P1: RATE_TYPE of the transaction 1 byte P2: TYPE and EXTENSION 1 byte LC: Length of the data section LC bytes DATA, content depends of the COMMAND"},{"location":"technical_information/protocol/#command","title":"COMMAND:","text":"Name Value Description GET_VERSION 0x02 Get application version. This APDU can be sent independently of the current app state START_NEW_TRANSACTION 0x03 Start new EXCHANGE transaction. This APDU resets the app state SET_PARTNER_KEY 0x04 Set the credentials of the exchange partner CHECK_PARTNER 0x05 Check that the credentials of the exchange partner are signed by the Ledger key PROCESS_TRANSACTION_RESPONSE 0x06 Receive the transaction proposal from the exchange partner CHECK_TRANSACTION_SIGNATURE 0x07 Check that the transaction proposal is signed by the exchange partner GET_CHALLENGE 0x10 Optional: Retrieve the current challenge value for the TLV trusted descriptor feature SEND_TRUSTED_NAME_DESCRIPTOR 0x11 Optional: Provide a TLV trusted descriptor CHECK_ASSET_IN_LEGACY_AND_DISPLAY 0x08 Format the amounts and fees used and prompts screen review (FUND_LEGACY and SELL_LEGACY flows only) CHECK_ASSET_IN_AND_DISPLAY 0x0B Format the amounts and fees used and prompts screen review (FUND based and SELL based flows) CHECK_ASSET_IN_NO_DISPLAY 0x0D Format the amounts and fees used. (FUND based and SELL based flows only) CHECK_PAYOUT_ADDRESS 0x08 Check that the payout address belongs to us (SWAP based flows only) CHECK_REFUND_ADDRESS_AND_DISPLAY 0x09 Check that the refund address belongs to us (SWAP based flows only) and prompts screen review CHECK_REFUND_ADDRESS_NO_DISPLAY 0x0C Check that the refund address belongs to us (SWAP based flows only) PROMPT_UI_DISPLAY 0x0F Prompt the screen review for the user START_SIGNING_TRANSACTION 0x0A Start the library application responsible for the FROM signing <p>The COMMANDS must be sent to the application in the correct order, this order depends of the TYPE chosen for the exchange flow:</p> All types START_NEW_TRANSACTION SET_PARTNER_KEY CHECK_PARTNER PROCESS_TRANSACTION_RESPONSE CHECK_TRANSACTION_SIGNATURE SWAP based TYPES or (discouraged version) FUND based and SELL based TYPES or (discouraged version) CHECK_PAYOUT_ADDRESS CHECK_PAYOUT_ADDRESS CHECK_ASSET_IN_NO_DISPLAY CHECK_ASSET_IN_AND_DISPLAY CHECK_REFUND_ADDRESS_NO_DISPLAY CHECK_REFUND_ADDRESS_AND_DISPLAY PROMPT_UI_DISPLAY PROMPT_UI_DISPLAY All types START_SIGNING_TRANSACTION"},{"location":"technical_information/protocol/#notes-on-commands","title":"Notes on COMMANDS:","text":"<ul> <li> <p>Command START_SIGNING_TRANSACTION requires that a UI review by the user has happened, either through a CHECK_X_AND_DISPLAY (legacy method), or through the dedicated PROMPT_UI_DISPLAY command.</p> </li> <li> <p>It is always possible to restart the flow by sending a START_NEW_TRANSACTION command, except when the UI review screen is being displayed.</p> </li> <li> <p>The command START_SIGNING_TRANSACTION will start the library application, the current application will not be EXCHANGE anymore.</p> </li> </ul>"},{"location":"technical_information/protocol/#rate_type","title":"RATE_TYPE:","text":"<p>Different possible rates for the transaction. The rate is sent to the app as P1 of an APDU.</p> Name Value Description FIXED 0x00 The rate in the transaction is a fixed value FLOATING 0x01 The rate in the transaction is an estimation"},{"location":"technical_information/protocol/#type","title":"TYPE:","text":"<p>Different exchange types are possible for the app. The type is sent to the app as the lowest 4 bits of the P2 byte of the APDU.</p> <p>Changing the subcommand after an exchange flow is started will result in an error response and the APDU is ignored.</p> Name Value Description SWAP_LEGACY 0x00 SWAP transaction (crypto against crypto) using legacy signature and encoding, deprecated by the NEW counterpart SELL_LEGACY 0x01 SELL transaction (crypto against fiat) using legacy signature and encoding, deprecated by the NEW counterpart FUND_LEGACY 0x02 FUND transaction (crypto to owned account) using legacy signature and encoding, deprecated by the NEW counterpart SWAP_NEW 0x03 SWAP transaction (crypto against crypto) using unified signature and encoding SELL_NEW 0x04 SELL transaction (crypto against fiat) using unified signature and encoding FUND_NEW 0x05 FUND transaction (crypto to owned account) using unified signature and encoding"},{"location":"technical_information/protocol/#extension","title":"EXTENSION:","text":"<p>This feature is only available in a PROCESS_TRANSACTION_RESPONSE command in a SWAP_NEW, SELL_NEW, or FUND_NEW flow.</p> <p>In Legacy flows the extension must be P2_NONE.</p> <p>The extension is sent to the app as the upper 4 bits of the P2 byte of the APDU.</p> <p>The maximum DATA in a single APDU is 255 bytes, in case it is not sufficient for a command, it is possible to use the EXTENSION feature to send the command in several parts.</p> <p>To use the EXTENSION feature, craft the data of the command you want to send and split it in 255 bytes chunks.</p> <p>Then send this chunks to the app using a combination of P2_EXTEND and P2_MORE in each APDU header.</p> <p>The application will reconstruct the DATA by concatenating the received APDUs.</p> <p>The application will refuse to reconstruct more than 512 bytes.</p> Name Value Description P2_NONE 0x00 &lt;&lt; 4 This APDU is self sufficient P2_EXTEND 0x01 &lt;&lt; 4 This APDU is not whole, it extends a previously received one P2_MORE 0x02 &lt;&lt; 4 This APDU is not whole, the followup part while be received later"},{"location":"technical_information/protocol/#data","title":"DATA:","text":""},{"location":"technical_information/protocol/#get_version","title":"GET_VERSION","text":"<p>No data expected.</p>"},{"location":"technical_information/protocol/#start_new_transaction","title":"START_NEW_TRANSACTION","text":"<p>No data expected.</p>"},{"location":"technical_information/protocol/#set_partner_key","title":"SET_PARTNER_KEY","text":""},{"location":"technical_information/protocol/#for-all-legacy-types-the-data-for-this-command-is","title":"For all LEGACY TYPES, the data for this command is:","text":"Bytes Description 1 byte Length N of the encoded partner name N bytes Partner name encoded with utf-8 LC - (1 + N) bytes Partner public key"},{"location":"technical_information/protocol/#for-all-unified-types-the-data-for-this-command-is","title":"For all UNIFIED TYPES, the data for this command is:","text":"Bytes Description 1 byte Length N of the encoded partner name N bytes Partner name encoded with utf-8 1 byte Curve used by the partner LC - (2 + N) bytes Partner public key <p>With the possible values for the curve being 0x00 for SECP256K1, and 0x01 for SECP256R1.</p>"},{"location":"technical_information/protocol/#check_partner","title":"CHECK_PARTNER","text":"Bytes Description LC bytes Signature of the partner credentials by the Ledger key, curve secp256k1 hashfunc sha256"},{"location":"technical_information/protocol/#process_transaction_response","title":"PROCESS_TRANSACTION_RESPONSE","text":"<p>Please refer to the src/protobuf files for the actual transaction proposal content.</p>"},{"location":"technical_information/protocol/#for-all-legacy-types-the-data-for-this-command-is_1","title":"For all LEGACY TYPES, the data for this command is:","text":"Bytes Description 1 byte Length N of the encoded transaction proposal N bytes Transaction proposal. Bytes array for SWAP_LEGACY, URLsafe base 64 encoding for SELL_LEGACY and FUND_LEGACY 1 byte Length M of the transaction fees M bytes Transaction fees"},{"location":"technical_information/protocol/#for-all-unified-types-the-data-for-this-command-is_1","title":"For all UNIFIED TYPES, the data for this command is:","text":"Bytes Description 1 byte Format used for the transaction encoding 2 bytes Length N of the encoded transaction proposal N bytes Encoded transaction proposal 1 byte Length M of the transaction fees M bytes Transaction fees <p>With the possible values for the format being 0x00 for Bytes Array (no encoding), and 0x01 for Base 64 Url encoding.</p> <p>The DATA of this command may exceed the capacity of a single APDU (255 bytes), in this case use the EXTENSION feature.</p>"},{"location":"technical_information/protocol/#get_challenge","title":"GET_CHALLENGE","text":"<p>Retrieve the current challenge value for the TLV trusted descriptor feature.</p> <p>It will be regenerated on application side following a SEND_TRUSTED_NAME_DESCRIPTOR command (successful or not).</p>"},{"location":"technical_information/protocol/#send_trusted_name_descriptor","title":"SEND_TRUSTED_NAME_DESCRIPTOR","text":"<p>Provide a TLV trusted descriptor from the CAL to apply a trusted value upon the refund or payout address.</p>"},{"location":"technical_information/protocol/#check_transaction_signature","title":"CHECK_TRANSACTION_SIGNATURE","text":""},{"location":"technical_information/protocol/#for-all-legacy-types-the-data-for-this-command-is_2","title":"For all LEGACY TYPES, the data for this command is:","text":"Bytes Description LC bytes Signature of the computed transaction proposed by the partner <p>For SWAP_LEGACY TYPE, the signature is computed on the transaction proposal.</p> <p>For SELL_LEGACY and FUND_LEGACY the signature is computed on the transaction proposal prefixed with a DOT ('.').</p> <p>For SWAP_LEGACY and FUND_LEGACY, the signature is in DER format.</p> <p>For SELL_LEGACY the signature is in (R,S) format.</p>"},{"location":"technical_information/protocol/#for-all-unified-types-the-data-for-this-command-is_2","title":"For all UNIFIED TYPES, the data for this command is:","text":"Bytes Description 1 byte If the signature is computed on a prefixed transaction 1 byte Format of the signature itself LC - 2 bytes Signature of the computed transaction proposed by the partner <p>With the possible values for the format of the transaction used for signing being 0x01 if it was DOT ('.') prefixed, 0x00 otherwise.</p> <p>With the possible values for the format of the signature itself being 0x00 for DER format, and 0x01 for (R,S) format.</p>"},{"location":"technical_information/protocol/#check_asset_in_legacy_and_display","title":"CHECK_ASSET_IN_LEGACY_AND_DISPLAY","text":"<p>This command is DEPRECATED.</p> <p>Please refer to CHECK_ASSET_IN_AND_DISPLAY (strict equivalent but discouraged) or CHECK_ASSET_IN_NO_DISPLAY + PROMPT_UI_DISPLAY</p> <p>This command works only for the SELL_LEGACY and FUND_LEGACY TYPES, the data content is the same as CHECK_ASSET_IN_AND_DISPLAY only the INS byte is different (and does not collide with CHECK_PAYOUT_ADDRESS).</p>"},{"location":"technical_information/protocol/#check_asset_in_and_display","title":"CHECK_ASSET_IN_AND_DISPLAY","text":"<p>This command is the same as CHECK_ASSET_IN_NO_DISPLAY except that the application will prompt the UI review if the check is successful.</p> <p>Usage of this command is discouraged, please use CHECK_ASSET_IN_NO_DISPLAY + PROMPT_UI_DISPLAY instead.</p>"},{"location":"technical_information/protocol/#check_asset_in_no_display","title":"CHECK_ASSET_IN_NO_DISPLAY","text":"<p>This command is used for SELL based and FUND based TYPES.</p> Bytes Description 1 byte Coin configuration length of the FROM coin. The coin configuration is made of the ticker, appname, and subconf 1 byte Ticker name length N N bytes Ticker name of this the coin configuration. The ticker has to be the same as the FROM ticker 1 byte Application name length M M bytes Name of the application that can handle this currency 1 byte Sub coin configuration length R R bytes Sub coin configuration, used for tokens to specify an app the subticker and the decimals S bytes Signature of the coin configuration by the Ledger key in DER format, curve secp256k1 hashfunc sha256 1 byte Packed derivation path length T T bytes Packed derivation path used for the FROM coin"},{"location":"technical_information/protocol/#check_payout_address","title":"CHECK_PAYOUT_ADDRESS","text":"<p>This command is used only in the SWAP_LEGACY and SWAP_NEW TYPES.</p> Bytes Description 1 byte Coin configuration length of the TO coin. The coin configuration is made of the ticker, appname, and subconf 1 byte Ticker name length N N bytes Ticker name of this the coin configuration. The ticker has to be the same as the TO ticker 1 byte Application name length M M bytes Name of the application that can handle this currency 1 byte Sub coin configuration length R R bytes Sub coin configuration, used for tokens to specify an app the subticker and the decimals S bytes Signature of the coin configuration by the Ledger key in DER format, curve secp256k1 hashfunc sha256 1 byte Packed derivation path length T T bytes Packed derivation path used for the TO coin"},{"location":"technical_information/protocol/#check_refund_address_and_display","title":"CHECK_REFUND_ADDRESS_AND_DISPLAY","text":"<p>This command is the same as CHECK_REFUND_ADDRESS_NO_DISPLAY except that the application will prompt the UI review if the check is successful.</p> <p>Usage of this command is discouraged, please use CHECK_REFUND_ADDRESS_NO_DISPLAY + PROMPT_UI_DISPLAY instead.</p>"},{"location":"technical_information/protocol/#check_refund_address_no_display","title":"CHECK_REFUND_ADDRESS_NO_DISPLAY","text":"<p>This command is used only in the SWAP_LEGACY and SWAP_NEW TYPES.</p> Bytes Description 1 byte Coin configuration length of the FROM coin. The coin configuration is made of the ticker, appname, and subconf 1 byte Ticker name length N N bytes Ticker name of this the coin configuration. The ticker has to be the same as the FROM ticker 1 byte Application name length M M bytes Name of the application that can handle this currency 1 byte Sub coin configuration length R R bytes Sub coin configuration, used for tokens to specify an app the subticker and the decimals S bytes Signature of the coin configuration by the Ledger key in DER format, curve secp256k1 hashfunc sha256 1 byte Packed derivation path length T T bytes Packed derivation path used for the FROM coin"},{"location":"technical_information/protocol/#prompt_ui_display","title":"PROMPT_UI_DISPLAY","text":"<p>This command prompts the UI so the user can validate the transaction on screen.</p>"},{"location":"technical_information/protocol/#start_signing_transaction","title":"START_SIGNING_TRANSACTION","text":"<p>No data expected.</p>"},{"location":"technical_information/protocol/#response","title":"Response:","text":"Bytes Description N bytes Command specific data 2 bytes Return code"},{"location":"technical_information/protocol/#returned-data","title":"Returned data","text":"<p>Only the COMMANDS described below return data. All others only return a code.</p>"},{"location":"technical_information/protocol/#get_version_1","title":"GET_VERSION","text":"<p>In case of success, this command will return the application version in format {MAJOR.MINOR.PATCH}.</p>"},{"location":"technical_information/protocol/#start_new_transaction_1","title":"START_NEW_TRANSACTION","text":"<p>In case of success, this command will return a nonce called \"device transaction id\" used for the initiated flow.</p> <p>For TYPE SWAP_LEGACY, the format of this nonce is a 10 char array.</p> <p>For all other TYPES, the format of this nonce is a 32 bytes array.</p>"},{"location":"technical_information/protocol/#get_challenge_1","title":"GET_CHALLENGE","text":"<p>The current challenge value in u32 format.</p>"},{"location":"technical_information/protocol/#return-code","title":"Return code","text":"<p>Return code can be one of the following values:</p> Bytes Name Description 0x6A80 INCORRECT_COMMAND_DATA The DATA sent does not match the correct format for the COMMAND specified 0x6A81 DESERIALIZATION_FAILED Can't parse partner transaction proposal 0x6A82 WRONG_TRANSACTION_ID Transaction ID is not equal to one generated on the START_NEW_TRANSACTION step 0x6A83 INVALID_ADDRESS Refund or payout address doesn't belong to us 0x6A84 USER_REFUSED_TRANSACTION User refused the transaction proposal 0x6A85 INTERNAL_ERROR Internal error of the application 0x6A86 WRONG_P1 The P1 value is not a valid RATE 0x6A87 WRONG_P2_SUBCOMMAND The P2 lower 4 bits of the P2 byte is not a valid SUBCOMMAND 0x6A88 WRONG_P2_EXTENSION The P2 upper 4 bits of the P2 byte is not a valid EXTENSION 0x6A89 INVALID_P2_EXTENSION The extension is a valid value but is refused in the current context 0x6A8A MEMORY_CORRUPTION A child application started by Exchange has corrupted the Exchange application memory 0x6A8B AMOUNT_FORMATTING_FAILED A child application failed to format an amount provided by the partner 0x6A8C APPLICATION_NOT_INSTALLED The requested child application is not installed on the device 0x6A8D WRONG_EXTRA_ID_OR_EXTRA_DATA The values given for extra_id (memo) and / or extra_data (Thorswap like) are incorrect 0x6A8E WRONG_TLV_CHALLENGE The challenge provided in the descriptor does not match the challenge generated 0x6A8F WRONG_TLV_CONTENT The content of the descriptor does not fit the Exchange use case specification 0x6A90 MISSING_TLV_CONTENT The descriptor is missing requirement tags 0x6A91 WRONG_TRUSTED_NAME_TLV The content of the descriptor does not fit the common descriptor specification 0x6A92 USER_REFUSED_CROSS_SEED User refused the transaction proposal when prompted by the Cross Seed Swap warning 0x6E00 CLASS_NOT_SUPPORTED The CLASS is not 0xE0 0x6E01 MALFORMED_APDU The APDU header is malformed 0x6E02 INVALID_DATA_LENGTH The length of the DATA is refused for this COMMAND 0x6D00 INVALID_INSTRUCTION COMMAND is not in the \"Possible commands\" table 0x6D01 UNEXPECTED_INSTRUCTION COMMAND is in the \"Possible commands\" table but is refused in the current context 0x6D02 DESCRIPTOR_NOT_USED The received descriptor could not be applied to refund nor payout address 0x9D1A SIGN_VERIFICATION_FAIL The signature sent by this command does not match the data or the associated public key 0x9000 SUCCESS Success code"},{"location":"technical_information/coin_application_api/","title":"Coin Application API","text":"<p>The handle functions must be defined by each Coin application implementing the SWAP feature.</p> <p>Handlers are called by Exchange through the <code>os_lib_call</code> API, and dispatched by the <code>main()</code> and <code>library_app_main()</code> functions of the lib_standard_app.</p> <p>The Exchange application is responsible for handling the flow and sequencing of the SWAP.</p> <p><code>ledger-secure-sdk/lib_standard_app/main.c</code> <pre><code>/* This function is called by the main() function if this application was started by Exchange\n * through an os_lib_call() as opposed to being started from the Dashboard.\n *\n * We dispatch the Exchange request to the correct handler.\n * Handlers content are not defined in the `lib_standard_app`\n */\nWEAK void library_app_main(libargs_t *args)\n{\n    BEGIN_TRY\n    {\n        TRY\n        {\n            PRINTF(\"Inside library\\n\");\n            switch (args-&gt;command) {\n                case SIGN_TRANSACTION: {\n                    // Backup up transaction parameters and wipe BSS to avoid collusion with\n                    // app-exchange BSS data.\n                    bool success = swap_copy_transaction_parameters(args-&gt;create_transaction);\n                    if (success) {\n                        // BSS was wiped, we can now init these globals\n                        G_called_from_swap    = true;\n                        G_swap_response_ready = false;\n                        // Keep the address at which we'll reply the signing status\n                        G_swap_signing_return_value_address = &amp;args-&gt;create_transaction-&gt;result;\n\n                        common_app_init();\n\n#ifdef HAVE_NBGL\n                        nbgl_useCaseSpinner(\"Signing\");\n#endif  // HAVE_NBGL\n\n                        app_main();\n                    }\n                    break;\n                }\n                case CHECK_ADDRESS:\n                    swap_handle_check_address(args-&gt;check_address);\n                    break;\n                case GET_PRINTABLE_AMOUNT:\n                    swap_handle_get_printable_amount(args-&gt;get_printable_amount);\n                    break;\n                default:\n                    break;\n            }\n        }\n        CATCH_OTHER(e)\n        {\n            (void) e;\n            PRINTF(\"Exiting following exception: 0x%04X\\n\", e);\n        }\n        FINALLY\n        {\n            os_lib_end();\n        }\n    }\n    END_TRY;\n}\n</code></pre></p>"},{"location":"technical_information/coin_application_api/error_codes/","title":"Error responses for applications started by Exchange in SWAP context","text":"<p>This specification applies to the error responses returned by the Coin applications when started by Exchange for the final payment transaction of a SWAP.</p> <p>Replying valuable data when a final payment transaction is refused eases a lot the analysis, especially if the issue happens in production context and/or is hard to reproduce.</p>"},{"location":"technical_information/coin_application_api/error_codes/#rapdu-status-word","title":"RAPDU status word","text":"<p>Each application must define a unique status word for every Exchange-related error.</p>"},{"location":"technical_information/coin_application_api/error_codes/#rapdu-data","title":"RAPDU data","text":"<p>The first 2 bytes of the RAPDU data represent the error code. Format is 16 bits integer in big endian.</p> <p>The upper byte is common between all applications. It must be one of the following value:</p> Name Value Description ERROR_INTERNAL 0x00 Internal application error, forward to the Firmware team for analysis. ERROR_WRONG_AMOUNT 0x01 The amount does not match the one validated in Exchange. ERROR_WRONG_DESTINATION 0x02 The destination address does not match the one validated in Exchange. ERROR_WRONG_FEES 0x03 The fees are different from what was validated in Exchange. ERROR_WRONG_METHOD 0x04 The method used is invalid in Exchange context. ERROR_CROSSCHAIN_WRONG_MODE 0x05 The mode used for the cross-chain hash validation is not supported. ERROR_CROSSCHAIN_WRONG_METHOD 0x06 The method used is invalid in cross-chain Exchange context. ERROR_CROSSCHAIN_WRONG_HASH 0x07 The hash for the cross-chain transaction does not match the validated value. ERROR_GENERIC 0xFF A generic or unspecified error not covered by the specific error codes above.Refer to the remaining bytes for further details on the error. <p>The lower byte can be set by the application to refine the error code returned.</p> <p>So the error code for <code>ERROR_WRONG_METHOD</code> would be <code>0x04XX</code> with <code>XX</code> being application specific (can be <code>00</code> if there is nothing to refine).</p> <p>The remaining bytes of the data are application-specific and can include, but are not limited to:</p> <ul> <li>Debugging information (e.g., error logs or internal state).</li> <li>Field values (e.g., expected vs actual amounts, destination, fees).</li> <li>More specific error codes tailored to the application's context.</li> </ul>"},{"location":"technical_information/coin_application_api/error_codes/#helpers-api","title":"Helpers API","text":"<p>The standard application library define several helper function to return error codes from the Coin application.</p> <p><code>ledger-secure-sdk/lib_standard_app/swap_error_code_helpers.h</code> <pre><code>/**\n * Sends a basic swap error with no extra data.\n *\n * @param status_word RAPDU status word.\n * @param common_error_code Common error code defined in swap_error_common_code_t.\n * @param application_specific_error_code Application-specific error code.\n */\n__attribute__((noreturn)) void send_swap_error_simple(uint16_t status_word,\n                                                      uint8_t  common_error_code,\n                                                      uint8_t  application_specific_error_code);\n\n/**\n * Sends a swap error with one additional buffer data.\n *\n * @param status_word RAPDU status word.\n * @param common_error_code Common error code.\n * @param application_specific_error_code Application-specific error code.\n * @param buffer_data Additional application-specific error details.\n */\n__attribute__((noreturn)) void send_swap_error_with_buffer(uint16_t status_word,\n                                                           uint8_t  common_error_code,\n                                                           uint8_t  application_specific_error_code,\n                                                           const buffer_t buffer_data);\n\n/**\n * Sends a swap error with multiple buffers containing error details as data.\n *\n * @param status_word RAPDU status word.\n * @param common_error_code Common error code.\n * @param application_specific_error_code Application-specific error code.\n * @param buffer_data Array of buffers with error details. SWAP_ERROR_HELPER_MAX_BUFFER_COUNT\n * @param count Number of buffers provided.\n */\n#define SWAP_ERROR_HELPER_MAX_BUFFER_COUNT 8\n__attribute__((noreturn)) void send_swap_error_with_buffers(uint16_t status_word,\n                                                            uint8_t  common_error_code,\n                                                            uint8_t application_specific_error_code,\n                                                            const buffer_t *buffer_data,\n                                                            size_t          count);\n\n/**\n * Macro to send a swap error with a formatted string as data.\n *\n * Constructs a buffer from a formatted string and passes it to send_swap_error_with_buffers.\n * @param status_word RAPDU status word.\n * @param common_error_code Common error code.\n * @param application_specific_error_code Application-specific error code.\n * @param format printf-style format string.\n * @param ... Additional arguments for formatting.\n */\n// Immediately call snprintf here (no function wrapping it cleanly in a .c file).\n// This is because we don't have a vsnprintf implementation which would be needed if\n// we were to pass the va_args to an intermediate function.\n// See https://stackoverflow.com/a/150578\n#define send_swap_error_with_string(                                                             \\\n    status_word, common_error_code, application_specific_error_code, format, ...)                \\\n    do {                                                                                         \\\n        /* Up to a full data apdu minus the status word and the swap error code */               \\\n        char format_buffer[sizeof(G_io_apdu_buffer) - sizeof(status_word) - 2] = {0};            \\\n        /* snprintf always returns 0 on our platform, don't check the return value */            \\\n        /* See https://github.com/LedgerHQ/ledger-secure-sdk/issues/236 */                       \\\n        snprintf(format_buffer, sizeof(format_buffer), format, ##__VA_ARGS__);                   \\\n        PRINTF(\"send_swap_error_with_string %s\\n\", format_buffer);                               \\\n        buffer_t string_buffer;                                                                  \\\n        string_buffer.ptr    = (uint8_t *) &amp;format_buffer;                                       \\\n        string_buffer.size   = strnlen(format_buffer, sizeof(format_buffer));                    \\\n        string_buffer.offset = 0;                                                                \\\n        send_swap_error_with_buffers(                                                            \\\n            status_word, common_error_code, application_specific_error_code, &amp;string_buffer, 1); \\\n    } while (0)\n</code></pre></p>"},{"location":"technical_information/coin_application_api/error_codes/#example-of-api-usage-in-boilerplate","title":"Example of API usage in Boilerplate","text":"<p><code>app-boilerplate/src/swap/handle_swap_sign_transaction.c</code> <pre><code>/* Check if the Tx to sign have the same parameters as the ones previously validated */\nbool swap_check_validity(uint64_t amount,\n                         uint64_t fee,\n                         const uint8_t* destination,\n                         const token_info_t* token_info) {\n    PRINTF(\"Inside swap_check_validity\\n\");\n\n    if (!G_swap_validated.initialized) {\n        PRINTF(\"Swap structure is not initialized\\n\");\n        send_swap_error_simple(SW_SWAP_FAIL, SWAP_EC_ERROR_GENERIC, SWAP_ERROR_CODE);\n        // unreachable\n        os_sched_exit(0);\n    }\n\n    // Reject token transactions in swap context\n    if (G_context.tx_info.is_token_tx) {\n        if (is_token_swap()) {\n            // Check that the token is the expected one\n            if (strcmp(G_swap_validated.ticker, token_info-&gt;ticker) != 0 ||\n                G_swap_validated.decimals != token_info-&gt;decimals) {\n                PRINTF(\"Token info does not match\\n\");\n                PRINTF(\"Validated: %s (decimals: %d)\\n\",\n                       G_swap_validated.ticker,\n                       G_swap_validated.decimals);\n                PRINTF(\"Received: %s (decimals: %d)\\n\", token_info-&gt;ticker, token_info-&gt;decimals);\n                send_swap_error_simple(SW_SWAP_FAIL,\n                                       SWAP_EC_ERROR_WRONG_AMOUNT,\n                                       SWAP_ERROR_WRONG_TOKEN_INFO);\n                // unreachable\n                os_sched_exit(0);\n            } else {\n                PRINTF(\"Token info match\\n\");\n            }\n        } else {\n            PRINTF(\"Unexpected token transaction from swap context\\n\");\n            send_swap_error_simple(SW_SWAP_FAIL, SWAP_EC_ERROR_WRONG_METHOD, SWAP_ERROR_CODE);\n            // unreachable\n            os_sched_exit(0);\n        }\n    } else if (is_token_swap()) {\n        PRINTF(\"Token transactions expected from swap context\\n\");\n        send_swap_error_simple(SW_SWAP_FAIL, SWAP_EC_ERROR_WRONG_METHOD, SWAP_ERROR_CODE);\n        // unreachable\n        os_sched_exit(0);\n    }\n\n    if (G_swap_validated.amount != amount) {\n        PRINTF(\"Amount does not match, promised %lld, received %lld\\n\",\n               G_swap_validated.amount,\n               amount);\n        send_swap_error_simple(SW_SWAP_FAIL, SWAP_EC_ERROR_WRONG_AMOUNT, SWAP_ERROR_CODE);\n        // unreachable\n        os_sched_exit(0);\n    } else {\n        PRINTF(\"Amounts match \\n\");\n    }\n\n    if (G_swap_validated.fee != fee) {\n        PRINTF(\"Fee does not match, promised %lld, received %lld\\n\", G_swap_validated.fee, fee);\n        send_swap_error_simple(SW_SWAP_FAIL, SWAP_EC_ERROR_WRONG_FEES, SWAP_ERROR_CODE);\n        // unreachable\n        os_sched_exit(0);\n    } else {\n        PRINTF(\"Fees match \\n\");\n    }\n\n    char to[ADDRESS_LEN * 2 + 1] = {0};\n    format_hex(destination, ADDRESS_LEN, to, sizeof(to));\n    if (strcmp(G_swap_validated.recipient, to) != 0) {\n        PRINTF(\"Destination does not match\\n\");\n        PRINTF(\"Validated: %s\\n\", G_swap_validated.recipient);\n        PRINTF(\"Received: %s \\n\", to);\n        send_swap_error_simple(SW_SWAP_FAIL, SWAP_EC_ERROR_WRONG_DESTINATION, SWAP_ERROR_CODE);\n        // unreachable\n        os_sched_exit(0);\n    } else {\n        PRINTF(\"Destination is valid\\n\");\n    }\n    return true;\n}\n</code></pre></p>"},{"location":"technical_information/coin_application_api/swap_copy_transaction_parameters/","title":"swap_copy_transaction_parameters()","text":"<p><code>ledger-secure-sdk/lib_standard_app/swap_entrypoints.h</code> <pre><code>/* This handle is called when the user has validated on screen the transaction\n * proposal sent by the partner and started the FROM Coin application to sign\n * the payment transaction.\n *\n * This handler needs to save in the heap the details of what has been validated\n * in Exchange. These elements will be checked against the received transaction\n * upon its reception from the Ledger Live.\n *\n * return false on error, true otherwise\n */\nbool swap_copy_transaction_parameters(create_transaction_parameters_t *sign_transaction_params);\n</code></pre></p> <p><code>ledger-secure-sdk/lib_standard_app/swap_lib_calls.h</code> <pre><code>typedef struct create_transaction_parameters_s {\n    // INPUTS //\n    // Additional data when dealing with tokens\n    // Content is coin application specific\n    uint8_t *coin_configuration;\n    uint8_t  coin_configuration_length;\n\n    // The amount validated on the screen by the user\n    uint8_t *amount;\n    uint8_t  amount_length;\n\n    // The fees amount validated on the screen by the user\n    uint8_t *fee_amount;\n    uint8_t  fee_amount_length;\n\n    // The partner address that will receive the funds\n    char *destination_address;\n    char *destination_address_extra_id;\n\n    // OUTPUT //\n    // /!\\ This parameter is handled by the lib_standard_app, DO NOT interact\n    // with it in the Coin application\n    //\n    // After reception and signature or refusal of the transaction, the Coin\n    // application will return to Exchange. This boolean is used to inform the\n    // Exchange application of the result.\n    // Set to 1 if the transaction was successfully signed, 0 otherwise.\n    uint8_t result;\n} create_transaction_parameters_t;\n</code></pre></p>"},{"location":"technical_information/coin_application_api/swap_copy_transaction_parameters/#example-of-handle-implementation-in-boilerplate","title":"Example of handle implementation in Boilerplate","text":"<p><code>app-boilerplate/src/swap/handle_swap_sign_transaction.c</code> <pre><code>typedef struct swap_validated_s {\n    bool initialized;\n    uint64_t amount;\n    uint64_t fee;\n    char recipient[ADDRESS_LEN * 2 + 1];\n    uint8_t decimals;\n    char ticker[MAX_TICKER_SIZE];\n} swap_validated_t;\n\n/* Global variable used to store swap validation status */\nstatic swap_validated_t G_swap_validated;\n\nstatic bool is_token_swap(void) {\n    return (strcmp(G_swap_validated.ticker, \"BOL\") != 0 ||\n            G_swap_validated.decimals != EXPONENT_SMALLEST_UNIT);\n}\n\nbool swap_copy_transaction_parameters(create_transaction_parameters_t* params) {\n    PRINTF(\"Inside swap_copy_transaction_parameters\\n\");\n\n    if (params-&gt;destination_address == NULL) {\n        PRINTF(\"Destination address expected\\n\");\n        return false;\n    }\n\n    if (strlen(params-&gt;destination_address) != (ADDRESS_LEN * 2)) {\n        PRINTF(\"Destination address wrong length\\n\");\n        return false;\n    }\n\n    if (params-&gt;amount == NULL) {\n        PRINTF(\"Amount expected\\n\");\n        return false;\n    }\n\n    // first copy parameters to stack, and then to global data.\n    // We need this \"trick\" as the input data position can overlap with app globals\n    // and also because we want to memset the whole bss segment as it is not done\n    // when an app is called as a lib.\n    // This is necessary as many part of the code expect bss variables to\n    // initialized at 0.\n    swap_validated_t swap_validated;\n    explicit_bzero(&amp;swap_validated, sizeof(swap_validated));\n\n    // Save recipient as an uppercase string\n    for (int i = 0; i &lt; ADDRESS_LEN * 2; i++) {\n        if (params-&gt;destination_address[i] &gt;= 'a' &amp;&amp; params-&gt;destination_address[i] &lt;= 'z') {\n            swap_validated.recipient[i] = params-&gt;destination_address[i] - 'a' + 'A';\n        } else {\n            swap_validated.recipient[i] = params-&gt;destination_address[i];\n        }\n    }\n    PRINTF(\"Validated recipient: %s\\n\", swap_validated.recipient);\n\n    // Parse config and save decimals and ticker\n    // If there is no coin_configuration, consider that we are doing a SOL swap\n    if (params-&gt;coin_configuration == NULL) {\n        memcpy(swap_validated.ticker, \"BOL\", sizeof(\"BOL\"));\n        swap_validated.decimals = EXPONENT_SMALLEST_UNIT;\n    } else {\n        if (!swap_parse_config(params-&gt;coin_configuration,\n                               params-&gt;coin_configuration_length,\n                               swap_validated.ticker,\n                               sizeof(swap_validated.ticker),\n                               &amp;swap_validated.decimals)) {\n            PRINTF(\"Fail to parse coin_configuration\\n\");\n            return false;\n        }\n    }\n    PRINTF(\"Validated ticker: %s, decimals: %d\\n\", swap_validated.ticker, swap_validated.decimals);\n\n    // Save amount\n    if (!swap_str_to_u64(params-&gt;amount, params-&gt;amount_length, &amp;swap_validated.amount)) {\n        PRINTF(\"Failed to convert amount to uint64_t\\n\");\n        return false;\n    }\n    // Can't print u64\n    PRINTF(\"Validated amount: %.*H\\n\", sizeof(swap_validated.amount), &amp;swap_validated.amount);\n\n    // Save fee\n    if (!swap_str_to_u64(params-&gt;fee_amount, params-&gt;fee_amount_length, &amp;swap_validated.fee)) {\n        PRINTF(\"Failed to convert fee to uint64_t\\n\");\n        return false;\n    }\n    PRINTF(\"Validated fee: %.*H\\n\", sizeof(swap_validated.fee), &amp;swap_validated.fee);\n\n    swap_validated.initialized = true;\n\n    // Full reset the global variables\n    os_explicit_zero_BSS_segment();\n\n    // Commit from stack to global data, params becomes tainted but we won't access it anymore\n    memcpy(&amp;G_swap_validated, &amp;swap_validated, sizeof(swap_validated));\n\n    return true;\n}\n</code></pre></p>"},{"location":"technical_information/coin_application_api/swap_handle_check_address/","title":"swap_handle_check_address()","text":"<p><code>ledger-secure-sdk/lib_standard_app/swap_entrypoints.h</code> <pre><code>/* This handle is called when the Exchange application wants to ensure that a\n * given address belongs to the device.\n *\n * If the address does belong to the device, result is set to 1. Otherwise it\n * is set to 0.\n */\nvoid swap_handle_check_address(check_address_parameters_t *params);\n</code></pre></p> <p><code>ledger-secure-sdk/lib_standard_app/swap_lib_calls.h</code> <pre><code>typedef struct check_address_parameters_s {\n    // INPUTS //\n    // Additional data when dealing with tokens\n    // Content is coin application specific\n    uint8_t *coin_configuration;\n    uint8_t  coin_configuration_length;\n\n    // serialized path, segwit, version prefix, hash used, dictionary etc.\n    // fields and serialization format are coin application specific\n    uint8_t *address_parameters;\n    uint8_t  address_parameters_length;\n\n    // The address to check\n    char *address_to_check;\n\n    // Extra content that may be relevant depending on context: memo, calldata, ...\n    // Content is coin application specific\n    char *extra_id_to_check;\n\n    // OUTPUT //\n    // Set to 1 if the address belongs to the device. 0 otherwise.\n    int result;\n} check_address_parameters_t;\n</code></pre></p>"},{"location":"technical_information/coin_application_api/swap_handle_check_address/#example-of-handle-implementation-in-boilerplate","title":"Example of handle implementation in Boilerplate","text":"<p><code>app-boilerplate/src/swap/handle_check_address.c</code> <pre><code>#ifdef HAVE_SWAP\n#include \"swap.h\"\n#include \"buffer.h\"\n#include \"bip32.h\"\n#include \"crypto_helpers.h\"\n#include \"cx.h\"\n#include \"os.h\"\n\n#include \"types.h\"\n#include \"format.h\"\n#include \"address.h\"\n#include \"tx_types.h\"\n\n#include &lt;string.h&gt;\n\n/* Check that the address used to receive funds is owned by the device\n * check_address_parameters_t is defined in C SDK as:\n * struct {\n *   // IN\n *   uint8_t *coin_configuration;\n *   uint8_t  coin_configuration_length;\n *   // serialized path, segwit, version prefix, hash used, dictionary etc.\n *   // fields and serialization format depends on specific coin app\n *   uint8_t *address_parameters;\n *   uint8_t  address_parameters_length;\n *   char    *address_to_check;\n *   char    *extra_id_to_check;\n *   // OUT\n *   int result;\n * } check_address_parameters_t;\n */\nvoid swap_handle_check_address(check_address_parameters_t *params) {\n    PRINTF(\"Inside swap_handle_check_address\\n\");\n    params-&gt;result = 0;\n\n    if (params-&gt;address_parameters == NULL) {\n        PRINTF(\"derivation path expected\\n\");\n        return;\n    }\n    PRINTF(\"address_parameters %.*H\\n\",\n           params-&gt;address_parameters_length,\n           params-&gt;address_parameters);\n\n    if (params-&gt;address_to_check == NULL) {\n        PRINTF(\"Address to check expected\\n\");\n        return;\n    }\n    PRINTF(\"Address to check %s\\n\", params-&gt;address_to_check);\n    if (strlen(params-&gt;address_to_check) != (ADDRESS_LEN * 2)) {\n        PRINTF(\"Address to check expected length %d, not %d\\n\",\n               ADDRESS_LEN * 2,\n               strlen(params-&gt;address_to_check));\n        return;\n    }\n\n    buffer_t buf = {.ptr = params-&gt;address_parameters,\n                    .size = params-&gt;address_parameters_length,\n                    .offset = 0};\n\n    uint8_t bip32_path_len;\n    uint32_t bip32_path[MAX_BIP32_PATH];\n    pubkey_ctx_t pk_info = {0};\n\n    buffer_read_u8(&amp;buf, &amp;bip32_path_len);\n    buffer_read_bip32_path(&amp;buf, bip32_path, (size_t) bip32_path_len);\n\n    cx_err_t ret = bip32_derive_get_pubkey_256(CX_CURVE_256K1,\n                                               bip32_path,\n                                               bip32_path_len,\n                                               pk_info.raw_public_key,\n                                               pk_info.chain_code,\n                                               CX_SHA512);\n    if (ret != CX_OK) {\n        PRINTF(\"Failed to derive public key\\n\");\n        return;\n    }\n\n    uint8_t address[ADDRESS_LEN] = {0};\n    address_from_pubkey(pk_info.raw_public_key, address, sizeof(address));\n\n    char derived_address[41];\n    memset(derived_address, 0, sizeof(derived_address));\n    format_hex(address, sizeof(address), derived_address, sizeof(derived_address));\n    PRINTF(\"Derived address %s\\n\", derived_address);\n\n    PRINTF(\"Checked address %s\\n\", params-&gt;address_to_check);\n\n    if (strncmp(derived_address, params-&gt;address_to_check, sizeof(derived_address)) != 0) {\n        PRINTF(\"Addresses do not match\\n\");\n    } else {\n        PRINTF(\"Addresses match\\n\");\n        params-&gt;result = 1;\n    }\n}\n#endif  // HAVE_SWAP\n</code></pre></p>"},{"location":"technical_information/coin_application_api/swap_handle_get_printable_amount/","title":"swap_handle_get_printable_amount()","text":"<p><code>ledger-secure-sdk/lib_standard_app/swap_entrypoints.h</code> <pre><code>/* This handle is called when the Exchange application wants to format for\n * display an amount + ticker of a currency known by this application\n *\n * If the formatting succeeds, result is set to the formatted string. Otherwise\n * it is set to '\\0'.\n */\nvoid swap_handle_get_printable_amount(get_printable_amount_parameters_t *params);\n</code></pre></p> <p><code>ledger-secure-sdk/lib_standard_app/swap_lib_calls.h</code> <pre><code>typedef struct get_printable_amount_parameters_s {\n    // INPUTS //\n    // Additional data when dealing with tokens\n    // Content is coin application specific\n    uint8_t *coin_configuration;\n    uint8_t  coin_configuration_length;\n\n    // Raw amount in big number format\n    uint8_t *amount;\n    uint8_t  amount_length;\n\n    // Set to true if the amount to format is the fee of the swap.\n    bool is_fee;\n\n    // OUTPUT //\n    // Set to the formatted string if the formatting succeeds. 0 otherwise.\n    char printable_amount[MAX_PRINTABLE_AMOUNT_SIZE];\n} get_printable_amount_parameters_t;\n</code></pre></p>"},{"location":"technical_information/coin_application_api/swap_handle_get_printable_amount/#example-of-handle-implementation-in-boilerplate","title":"Example of handle implementation in Boilerplate","text":"<p><code>app-boilerplate/src/swap/handle_get_printable_amount.c</code> <pre><code>#ifdef HAVE_SWAP\n#include \"swap.h\"\n#include \"buffer.h\"\n#include \"constants.h\"\n#include \"format.h\"\n#include \"os.h\"\n#include \"tokens.h\"\n\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\n/* Format printable amount including the ticker from specified parameters.\n *\n * Must set empty printable_amount on error, printable amount otherwise\n * get_printable_amount_parameters_t is defined in C SDK as:\n * struct {\n *   // IN\n *   uint8_t *coin_configuration;\n *   uint8_t  coin_configuration_length;\n *   uint8_t *amount;\n *   uint8_t  amount_length;\n *   bool     is_fee;\n *   // OUT\n *   char printable_amount[MAX_PRINTABLE_AMOUNT_SIZE];\n * } get_printable_amount_parameters_t;\n */\nvoid swap_handle_get_printable_amount(get_printable_amount_parameters_t* params) {\n    PRINTF(\"Inside swap_handle_get_printable_amount\\n\");\n\n    PRINTF(\"Amount: %.*H\\n\", params-&gt;amount_length, params-&gt;amount);\n\n    explicit_bzero(params-&gt;printable_amount, sizeof(params-&gt;printable_amount));\n\n    /// Convert params-&gt;amount into uint64_t\n    uint64_t raw_amount = 0;\n    if (!swap_str_to_u64(params-&gt;amount, params-&gt;amount_length, &amp;raw_amount)) {\n        PRINTF(\"Amount is too big\\n\");\n        return;\n    }\n\n    uint8_t decimals = EXPONENT_SMALLEST_UNIT;\n    char ticker[MAX_TICKER_SIZE] = \"BOL\";\n    if (params-&gt;is_fee || params-&gt;coin_configuration == NULL) {\n        PRINTF(\"Defaulting to native BOL amount\\n\");\n    } else {\n        if (!swap_parse_config(params-&gt;coin_configuration,\n                               params-&gt;coin_configuration_length,\n                               ticker,\n                               sizeof(ticker),\n                               &amp;decimals)) {\n            PRINTF(\"Fail to parse coin_configuration\\n\");\n            return;\n        }\n    }\n    char formatted_amount[30] = {0};\n    format_fpu64(formatted_amount, sizeof(formatted_amount), raw_amount, decimals);\n    PRINTF(\"Formatted amount: %s\\n\", formatted_amount);\n    snprintf(params-&gt;printable_amount,\n             sizeof(params-&gt;printable_amount),\n             \"%.*s %s\",\n             (int) strlen(formatted_amount),\n             formatted_amount,\n             ticker);\n}\n#endif  // HAVE_SWAP\n</code></pre></p>"},{"location":"technical_information/coin_application_api/ui_bypass/","title":"UI bypass","text":"<p>The goal of the Exchange application is to allow the user to perform a fully trusted SWAP through a single screen UI review.</p> <p>The Exchange application handles the trust checking and the UI, the FROM coin application handles the final payment. This final payment needs to be validated without UI call as long as all conditions are strictly met.</p> <p>Please refer to the sequence diagram if you want to see the process flow in more details.</p> <p>The UI bypass on the coin application need to abide by the following rules:</p> <ul> <li>The bypass is used only when started by Exchange.</li> <li>The bypass is only used for a single type of simple transaction.</li> <li>The bypass is only used if the destination strictly matches.</li> <li>The bypass is only used if the amount strictly matches.</li> <li>The bypass is only used if the fees strictly matches.</li> </ul> <p>If a transaction received in the SWAP context does not match the requirements, it needs to be rejected without UI prompt. The Exchange application will handle the refusal screen display.</p> <p>Here is an example of the high level detection of the UI bypass.</p> <p><code>app-boilerplate/src/handler/sign_tx.c</code> <pre><code>#ifdef HAVE_SWAP\nstatic int check_and_sign_swap_tx(transaction_ctx_t *tx_ctx) {\n    if (G_swap_response_ready) {\n        // Safety against trying to make the app sign multiple TX\n        // This code should never be triggered as the app is supposed to exit after\n        // sending the signed transaction\n        PRINTF(\"Safety against double signing triggered\\n\");\n        os_sched_exit(-1);\n    } else {\n        // We will quit the app after this transaction, whether it succeeds or fails\n        PRINTF(\"Swap response is ready, the app will quit after the next send\\n\");\n        // This boolean will make the io_send_sw family instant reply + return to exchange\n        G_swap_response_ready = true;\n    }\n    if (swap_check_validity(tx_ctx-&gt;transaction.value,\n                            tx_ctx-&gt;transaction.fee,\n                            tx_ctx-&gt;transaction.to,\n                            &amp;tx_ctx-&gt;token_info)) {\n        PRINTF(\"Swap response validated, sign the transaction\\n\");\n        validate_transaction(true);\n    }\n    // Unreachable because swap_check_validity() returns an error to exchange app OR\n    // validate_transaction() returns a success to exchange\n    os_sched_exit(0);\n    return 0;\n}\n#endif  // HAVE_SWAP\n</code></pre></p> <p>Here is the function <code>swap_check_validity()</code> called for checking the content of the received TX against the data validated in the Exchange application, </p> <p><code>app-boilerplate/src/swap/handle_swap_sign_transaction.c</code> <pre><code>/* Check if the Tx to sign have the same parameters as the ones previously validated */\nbool swap_check_validity(uint64_t amount,\n                         uint64_t fee,\n                         const uint8_t* destination,\n                         const token_info_t* token_info) {\n    PRINTF(\"Inside swap_check_validity\\n\");\n\n    if (!G_swap_validated.initialized) {\n        PRINTF(\"Swap structure is not initialized\\n\");\n        send_swap_error_simple(SW_SWAP_FAIL, SWAP_EC_ERROR_GENERIC, SWAP_ERROR_CODE);\n        // unreachable\n        os_sched_exit(0);\n    }\n\n    // Reject token transactions in swap context\n    if (G_context.tx_info.is_token_tx) {\n        if (is_token_swap()) {\n            // Check that the token is the expected one\n            if (strcmp(G_swap_validated.ticker, token_info-&gt;ticker) != 0 ||\n                G_swap_validated.decimals != token_info-&gt;decimals) {\n                PRINTF(\"Token info does not match\\n\");\n                PRINTF(\"Validated: %s (decimals: %d)\\n\",\n                       G_swap_validated.ticker,\n                       G_swap_validated.decimals);\n                PRINTF(\"Received: %s (decimals: %d)\\n\", token_info-&gt;ticker, token_info-&gt;decimals);\n                send_swap_error_simple(SW_SWAP_FAIL,\n                                       SWAP_EC_ERROR_WRONG_AMOUNT,\n                                       SWAP_ERROR_WRONG_TOKEN_INFO);\n                // unreachable\n                os_sched_exit(0);\n            } else {\n                PRINTF(\"Token info match\\n\");\n            }\n        } else {\n            PRINTF(\"Unexpected token transaction from swap context\\n\");\n            send_swap_error_simple(SW_SWAP_FAIL, SWAP_EC_ERROR_WRONG_METHOD, SWAP_ERROR_CODE);\n            // unreachable\n            os_sched_exit(0);\n        }\n    } else if (is_token_swap()) {\n        PRINTF(\"Token transactions expected from swap context\\n\");\n        send_swap_error_simple(SW_SWAP_FAIL, SWAP_EC_ERROR_WRONG_METHOD, SWAP_ERROR_CODE);\n        // unreachable\n        os_sched_exit(0);\n    }\n\n    if (G_swap_validated.amount != amount) {\n        PRINTF(\"Amount does not match, promised %lld, received %lld\\n\",\n               G_swap_validated.amount,\n               amount);\n        send_swap_error_simple(SW_SWAP_FAIL, SWAP_EC_ERROR_WRONG_AMOUNT, SWAP_ERROR_CODE);\n        // unreachable\n        os_sched_exit(0);\n    } else {\n        PRINTF(\"Amounts match \\n\");\n    }\n\n    if (G_swap_validated.fee != fee) {\n        PRINTF(\"Fee does not match, promised %lld, received %lld\\n\", G_swap_validated.fee, fee);\n        send_swap_error_simple(SW_SWAP_FAIL, SWAP_EC_ERROR_WRONG_FEES, SWAP_ERROR_CODE);\n        // unreachable\n        os_sched_exit(0);\n    } else {\n        PRINTF(\"Fees match \\n\");\n    }\n\n    char to[ADDRESS_LEN * 2 + 1] = {0};\n    format_hex(destination, ADDRESS_LEN, to, sizeof(to));\n    if (strcmp(G_swap_validated.recipient, to) != 0) {\n        PRINTF(\"Destination does not match\\n\");\n        PRINTF(\"Validated: %s\\n\", G_swap_validated.recipient);\n        PRINTF(\"Received: %s \\n\", to);\n        send_swap_error_simple(SW_SWAP_FAIL, SWAP_EC_ERROR_WRONG_DESTINATION, SWAP_ERROR_CODE);\n        // unreachable\n        os_sched_exit(0);\n    } else {\n        PRINTF(\"Destination is valid\\n\");\n    }\n    return true;\n}\n</code></pre></p> <p>The Boilerplate does not have tokens, as a result there is no check on the type of currency signed. If your application is able to handle multiple currencies, this is a check that you must add.</p>"},{"location":"walkthrough/","title":"Enabling the SWAP on your application","text":"<p>This guide will help you add SWAP compatibility to your application.</p> <p>It follows a Test-Driven approach.</p> <p>Do not hesitate to refer to the Technical Information section.</p>"},{"location":"walkthrough/code_the_handlers/","title":"Code the handlers","text":""},{"location":"walkthrough/code_the_handlers/#code-the-handlers-to-make-the-first-tests-pass","title":"Code the handlers to make the first tests pass","text":"<p>The next step is to implement the first two handlers so that the tests <code>swap_ui_only</code> and <code>swap_wrong_refund</code> pass.</p>"},{"location":"walkthrough/code_the_handlers/#test-swap_ui_only","title":"Test <code>swap_ui_only</code>","text":"<p>This test stops before sending the <code>START_SIGNING_TRANSACTION</code> APDU. That means no coin signature takes place; the only handlers called are <code>swap_handle_check_address()</code> and <code>swap_handle_get_printable_amount()</code>.</p> <p>You can use this test to validate that:</p> <ul> <li><code>swap_handle_check_address()</code> correctly recognizes the <code>valid_destination_1</code> address.</li> <li><code>swap_handle_get_printable_amount()</code> correctly formats the amount for display.</li> </ul> <p>Don't forget to run ragger with the <code>--golden_run</code> option when creating or updating the snapshots.</p>"},{"location":"walkthrough/code_the_handlers/#test-swap_wrong_refund","title":"Test <code>swap_wrong_refund</code>","text":"<p>This test sends a refund address that does not belong to the device.</p> <p>You can use this test to validate that <code>swap_handle_check_address()</code> correctly rejects the <code>fake_refund</code> address.</p>"},{"location":"walkthrough/code_the_handlers/#code-the-last-handler-and-the-ui-bypass","title":"Code the last handler and the UI bypass","text":"<p>You can now implement the <code>swap_copy_transaction_parameters()</code> handler.</p> <p>You can also implement the UI bypass for the final transaction signature.</p> <p>Please refer to the UI bypass documentation carefully.</p> <p>Please refer to the Coin application error codes to learn how to handle a refusal of the final transaction.</p> <p>All tests should now pass.</p>"},{"location":"walkthrough/enable_standard_app/","title":"Creating a basic SWAP test for you coin","text":""},{"location":"walkthrough/enable_standard_app/#add-the-cal-data-for-your-application","title":"Add the CAL data for your application","text":"<p>You can find more information about what the CAL is and how it is used in the Crypto Asset List section.</p> <p>Modify the cal_helper.py file to craft your coin configuration instead of the Boilerplate one.</p> <p>Do not use the <code>sub_coin_config</code> field for now. You can use it later for tokens if needed; for the time being, the standard configuration is sufficient to get started.</p>"},{"location":"walkthrough/enable_standard_app/#enable-the-exchange-tests-for-your-application","title":"Enable the Exchange tests for your application","text":"<p>The core of the Exchange tests is handled by the ExchangeTestRunner class in the Exchange test client.</p> <p>Individual tests import and extend the ExchangeTestRunner class to leverage the test framework it provides.</p> <p>Write a first draft of the Exchange tests for your application, using the Boilerplate tests as an example:</p> <p>tests/swap/test_boilerplate.py</p> <p>You can leave the <code>perform_final_tx()</code> function empty for now if you prefer.</p> <p>You can validate this step by running the <code>swap_ui_only()</code> test for your coin. It should pass, as we coded empty \u201cyes-man\u201d handlers for our tests in the previous section.</p>"},{"location":"walkthrough/enable_the_swap_compilation/","title":"First compilation with the standard SWAP","text":""},{"location":"walkthrough/enable_the_swap_compilation/#enable-the-swap-feature","title":"Enable the SWAP feature","text":"<p>In the Makefile, set the variable <code>ENABLE_SWAP = 1</code> or <code>ENABLE_TESTING_SWAP = 1</code> of the standard Makefile, as shown in the example below:</p> <p><code>app-boilerplate/Makefile</code> <pre><code>ifeq ($(APPNAME), \"Boilerplate\")\n# Two flags exist for enabling the SWAP\n#   - ENABLE_SWAP           will lead to the enabling of the swap related C code of the standard_app\n#                           AND will lead to the enabling of the APP_LOAD_PARAM required for os_lib_call working on device\n#   - ENABLE_TESTING_SWAP:  will lead to the enabling of the swap related C code of the standard_app\n#                           ONLY works on Speculos, not on device\n# Testing only SWAP flag\nENABLE_TESTING_SWAP = 1\n# Production enabled SWAP flag\n# ENABLE_SWAP = 1\nendif\n</code></pre></p> <p>Then compile your application, you may encounter the following error if you do not have a recent Boilerplate fork:</p> <pre><code>ld.lld: error: undefined symbol: swap_copy_transaction_parameters\n&gt;&gt;&gt; referenced by main.c\n&gt;&gt;&gt;               build/nanox/obj/sdk/lib_standard_app/main.o:(library_app_main)\n\nld.lld: error: undefined symbol: swap_handle_get_printable_amount\n&gt;&gt;&gt; referenced by main.c\n&gt;&gt;&gt;               build/nanox/obj/sdk/lib_standard_app/main.o:(library_app_main)\n\nld.lld: error: undefined symbol: swap_handle_check_address\n&gt;&gt;&gt; referenced by main.c\n&gt;&gt;&gt;               build/nanox/obj/sdk/lib_standard_app/main.o:(library_app_main)\n</code></pre> <p>These errors are caused by the missing handler definitions. For more information about what the handlers do, refer to the handler documentation.</p>"},{"location":"walkthrough/enable_the_swap_compilation/#fix-compilation-errors-if-any","title":"Fix compilation errors if any","text":"<p>If the compilation succeeds, you can skip this section.</p> <p>For now, we will declare the handlers in the simplest possible way.</p> <p>Add the following files to your application (it is recommended to follow the Boilerplate file structure): <pre><code>$&gt; ls app-boilerplate/src/swap/\nhandle_check_address.c  handle_get_printable_amount.c  handle_swap.h  handle_swap_sign_transaction.c\n</code></pre></p> <p>Add the function declarations in the <code>.h</code> files and the function definitions in the <code>.c</code> files. Define empty functions for now:</p> <pre><code>#include \"os.h\"\n#include \"swap_lib_calls.h\"\n\nvoid swap_handle_check_address(check_address_parameters_t *params) {\n    // Accept all addresses\n    params-&gt;result = 1;\n}\n\nvoid swap_handle_get_printable_amount(get_printable_amount_parameters_t* params) {\n    // Format all amounts as 10\n    strcpy(params-&gt;printable_amount, \"10\");\n}\n\nbool swap_copy_transaction_parameters(create_transaction_parameters_t* params) {\n    // Do nothing successfully\n    return true;\n}\n</code></pre>"},{"location":"walkthrough/prerequisite/","title":"Prerequisite","text":"<p>Before proceeding with the SWAP integration, ensure that your application:</p> <ul> <li>Uses the Standard Makefile.</li> <li>Follows the Standard application format.</li> <li>Has the correct tests structure.</li> </ul> <p>Although these steps may seem unrelated to the SWAP feature, they significantly simplify the integration process, to the point that no support is provided if you skip them.</p> <p>You should use the app-boilerplate as an example. Depending on the date of your fork from the Boilerplate application, most of these steps may already be done.</p>"},{"location":"walkthrough/prerequisite/#standard-makefile","title":"Standard Makefile","text":"<p>Ensure that, like the Boilerplate Makefile, your Makefile contains: <pre><code>include $(BOLOS_SDK)/Makefile.standard_app\n</code></pre></p>"},{"location":"walkthrough/prerequisite/#standard-application-files","title":"Standard application files","text":"<p>Ensure that, like the Boilerplate Makefile, the <code>DISABLE_STANDARD_APP_FILES</code> is not set to <code>1</code>:</p>"},{"location":"walkthrough/prerequisite/#test-structure","title":"Test structure","text":"<p>Ensure that your tests directory follows the structure below: <pre><code>$&gt; ls app-boilerplate/tests/\napplication_client\nREADME.md\nstandalone\nswap\n</code></pre></p> <p>The <code>application_client</code> directory contains the minimalist python client for crafting and sending APDUs to the application. It is extracted in order to be able to be used in both tests setup.</p> <p>The <code>standalone</code> directory contains the standalone tests of the application, when it is started from the Dashboard of the device (main use case).</p> <p>The <code>swap</code> directory contains the tests of the SWAP feature of the application, when it is started by the Exchange application through the <code>os_lib_call</code> API. This setup needs the Exchange and Ethereum binaries compiled.</p>"},{"location":"walkthrough/run_first_test/","title":"Running an existing SWAP test","text":"<p>This page provides all the essential setup details to help you get started with enabling the SWAP feature in your application.</p> <p>The Boilerplate application will be used as an example.</p>"},{"location":"walkthrough/run_first_test/#understanding-the-exchange-test-framework","title":"Understanding the Exchange test framework","text":"<p>Please look at the sequence diagram. You will see that, in order to perform a SWAP, several communication and authentication steps between Ledger Wallet (here mocked by Ragger) and the device are required.</p> <p>These steps are outside the scope of testing your application. We provide the Exchange client, hosted in the Exchange application repository, to perform them automatically.</p> <p>Looking again at the sequence diagram, the only Python code you will have to write is the Sign transaction request once your application has been started by Exchange.</p>"},{"location":"walkthrough/run_first_test/#the-swap-functional-tests-setup","title":"The Swap functional tests setup","text":"<p>The swap test suite validates the application when it is used by the Exchange application through the os_lib_call mechanism to perform the swap feature.</p> <p>This mode uses dedicated launch code and requires a different Speculos setup.</p> <p>These tests are written using:</p> <ul> <li>pytest \u2014 Python testing framework</li> <li>Ragger \u2014 Ledger's open-source testing library for simulating device interactions</li> <li>The python module ledger_app_clients.exchange,   the helper module to easily emulate the SWAP context.</li> </ul> <p>Directory structure brief overview:</p> <pre><code>swap/\n|\u2500\u2500 cal_helper.py                     # A fake CAL configuration for the BOL currency\n\u251c\u2500\u2500 conftest.py                       # Pytest fixtures and device setup\n\u251c\u2500\u2500 test_boilerplate.py               # Functional test cases\n\u251c\u2500\u2500 helper_tool_build_dependencies.py # A helper script to pull Exchange and Ethereum applications (needed for Speculos to emulate a swap)\n\u251c\u2500\u2500 helper_tool_clone_dependencies.py # A helper script to compile pulled Exchange and Ethereum applications (run after helper_tool_build_dependencies.py INSIDE the Docker)\n\u251c\u2500\u2500 snapshots/                        # Ragger UI snapshots\n\u251c\u2500\u2500 snapshots-tmp/                    # Temporary snapshot diffs (not tracked in git)\n\u251c\u2500\u2500 requirements.txt                  # Python dependencies\n</code></pre>"},{"location":"walkthrough/run_first_test/#compile-your-application","title":"Compile your application","text":"<p>Build your application in the Ledger docker environment.</p>"},{"location":"walkthrough/run_first_test/#compile-the-exchange-and-ethereum-applications","title":"Compile the Exchange and Ethereum applications","text":"<p>First, install helper python dependencies in your native (host) environment</p> <pre><code>pip install -U GitPython\n</code></pre> <p>Then, execute the clone script in your native (host) environment</p> <pre><code>python helper_tool_clone_dependencies.py\n</code></pre> <p>Then, execute the build script in the Ledger docker environment. You can use the following command when located in the <code>tests/swap</code> directory.</p> <pre><code>docker run --user \"$(id -u)\":\"$(id -g)\" --rm -ti -v \"$(realpath .):/app\" \"ghcr.io/ledgerhq/ledger-app-builder/ledger-app-builder:latest\" python3 helper_tool_build_dependencies.py\n</code></pre>"},{"location":"walkthrough/run_first_test/#running-a-first-exchange-test","title":"Running a first Exchange test","text":"<p>If you are on Linux or WSL, you can run the tests in your native (host) environment.</p> <p>If you are on MAC you need to run the tests in the Ledger docker environment.</p>"},{"location":"walkthrough/run_first_test/#install-python-dependencies","title":"Install python dependencies","text":"<p>Install python dependencies</p> <pre><code>pip install -r tests/swap/requirements.txt --break-system-packages\n</code></pre>"},{"location":"walkthrough/run_first_test/#run-a-simple-test","title":"Run a simple test","text":"<p>To see all available tests:</p> <pre><code>pytest -v --tb=short tests/swap/ --device all --collect-only\n</code></pre> <p>To list only SWAP tests for Stax:</p> <pre><code>pytest -v --tb=short tests/swap/ --device stax --collect-only -k swap\n</code></pre> <p>To run a specific test for Stax:</p> <pre><code>pytest -v --tb=short tests/swap/ --device stax -k 'swap_ui_only' -s\n</code></pre> <p>Running a single test will be useful later for test driven development, don't hesitate to come back to this command and adapt it.</p>"},{"location":"walkthrough/run_first_test/#next-steps","title":"Next steps","text":"<p>Now that you know how to set up and run the swap tests, you will be able to add tests for your own application and run them as you develop the SWAP feature.</p>"}]}