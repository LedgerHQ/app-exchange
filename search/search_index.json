{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ledger Swap documentation","text":"<p>This documentation is designed to help you understand how the Ledger Swap feature works and guide you through modifying your coin application to be compatible with it.</p> <p>The Swap feature enables users to securely exchange one cryptocurrency for another directly from their Ledger device, within Ledger Live. It uses a trusted, multi-step process to facilitate communication between Ledger Live, the Trade Partner, the Exchange application, and the respective Coin applications on the device.</p> <p>Built with robust security at every stage, the process includes cryptographic validation and transaction signatures. Final confirmation is conducted directly on the device screen, ensuring that only validated transactions are signed and authorized.</p>"},{"location":"#key-components-of-the-swap-flow","title":"Key Components of the Swap Flow","text":"<p>The Swap process involves the following actors:</p> <ul> <li>The Trade Partner: Proposes a trade offer to the Ledger Live user, which must be clearly displayed on the device screen by the Exchange application.</li> <li>The Ledger Live: initiates and manages the transaction flow between the Partner and the Exchange application.</li> <li>The Exchange Application: serves as the intermediary between the Ledger Live, the involved coin applications, and the user.</li> <li>The Coin Applications: Handle the processing for both the FROM and TO currencies involved in the swap.</li> <li>The Ledger Crypto Asset List (CAL): Contains HSM signed data of all SWAP compatible currencies that will help the Exchange application display the transaction proposal content on screen. </li> </ul> <pre><code>---\ntitle: Swap FROM currency -&gt; TO currency actors\n---\nflowchart LR\n    classDef invisible width:0px,height:0px,stroke-width:0px,fill:transparent;\n\n    subgraph P[TRADE PARTNER]\n        PAR@{ shape: rounded, label: \"Trade partner\" }\n    end\n\n    subgraph HSM[LEDGER HSM]\n        CAL@{ shape: rounded, label: \"Crypto&lt;br&gt;Asset List\" }\n    end\n\n    subgraph LL[LEDGER LIVE]\n        LLC@{ shape: rounded, label: \"Ledger Live\" }\n        %% Fake node to force the Partner -&gt; Exchange line to go through the LL box\n        FAKE((\" \")):::invisible\n    end\n\n    subgraph D[DEVICE]\n        EX@{ shape: rounded, label: \"Exchange&lt;br&gt;application\" }\n        FROM@{ shape: rounded, label: \"FROM&lt;br&gt;Coin application\" }\n        TO@{ shape: rounded, label: \"TO&lt;br&gt;Coin application\" }\n        SCREEN@{ shape: rounded, label: \"Device screen\" }\n    end\n\n    PAR &lt;-- \"&lt;div style='background:transparent;'&gt;Trade&lt;br&gt;establishment\" --&gt;LLC\n    PAR -- \"&lt;div style='background:transparent;'&gt;Signed transaction&lt;br&gt;proposal\" ---FAKE\n\n    CAL -- \"&lt;div style='background:transparent;'&gt;Coin&lt;br&gt;configurations\" --- FAKE\n\n    LLC &lt;-- \"&lt;div style='background:transparent;'&gt;Final payment request&lt;br&gt;/&lt;br&gt;Signature or refusal\" --&gt;FROM\n    LLC &lt;-- \"&lt;div style='background:transparent;'&gt;APDUs&lt;br&gt;/&lt;br&gt;RAPDUs\" --&gt;EX\n\n    EX &lt;-- \"&lt;div style='background:transparent;'&gt;Format amount&lt;br&gt;Address check\" --&gt;TO\n    EX &lt;-- \"&lt;div style='background:transparent;'&gt;Format amount&lt;br&gt;Address check&lt;br&gt;Final transaction details\" --&gt;FROM\n    FAKE --&gt;EX\n    EX &lt;-- \"&lt;div style='background:transparent;'&gt;User review\" --&gt;SCREEN</code></pre>"},{"location":"deps/app-solana/","title":"Index","text":""},{"location":"deps/app-solana/#solana-app-for-ledger-wallet","title":"Solana app for Ledger Wallet","text":""},{"location":"deps/app-solana/#overview","title":"Overview","text":"<p>This app adds support for the Solana native token to Ledger Nano S hardware wallet.</p> <p>Current Features: - Pubkey queries - Parse, display and sign all Solana CLI generated transaction formats - Blind sign arbitrary transactions (Enabled via settings)</p>"},{"location":"deps/app-solana/#prerequisites","title":"Prerequisites","text":""},{"location":"deps/app-solana/#for-building-the-app","title":"For building the app","text":"<ul> <li>Install Docker</li> <li>For Linux hosts, install the Ledger Nano udev rules</li> <li>Pull Ledger Development Tools image</li> </ul> <pre><code>$ docker pull ghcr.io/ledgerhq/ledger-app-builder/ledger-app-dev-tools:latest\n</code></pre>"},{"location":"deps/app-solana/#build","title":"Build","text":"<p>Build the app in the container. The BOLOS_SDK variable is used to specify the target SDK, allowing to compile the application for each Ledger device. See Ledger Application Builder for more details.</p> <pre><code># E.g. for Nano S\n$ sudo docker run --rm -ti -v \"$(realpath .):/app\" --user $(id -u $USER):$(id -g $USER) ghcr.io/ledgerhq/ledger-app-builder//ledger-app-dev-tools:latest\nbash$ BOLOS_SDK=$NANOS_SDK make\n</code></pre>"},{"location":"deps/app-solana/#clean","title":"Clean","text":"<p>Within the running development container</p> <pre><code>bash$ BOLOS_SDK=$NANOS_SDK make clean\n</code></pre>"},{"location":"deps/app-solana/#working-with-the-device","title":"Working with the device","text":"<p>See Ledger Application Builder for more details. </p>"},{"location":"deps/app-solana/#load","title":"Load","text":"<pre><code>$ sudo docker run --rm -ti  -v \"$(realpath .):/app\" --privileged -v \"/dev/bus/usb:/dev/bus/usb\" --user $(id -u $USER):$(id -g $USER) ghcr.io/ledgerhq/ledger-app-builder/ledger-app-dev-tools:latest\nbash$ BOLOS_SDK=$NANOS_SDK make load\n</code></pre>"},{"location":"deps/app-solana/#delete","title":"Delete","text":"<p>Within the running development container</p> <pre><code>bash$ BOLOS_SDK=$NANOS_SDK make delete\n</code></pre>"},{"location":"deps/app-solana/#test","title":"Test","text":""},{"location":"deps/app-solana/#unit","title":"Unit","text":"<p>Run C tests:</p> <pre><code>bash$ make -C libsol\n</code></pre>"},{"location":"deps/app-solana/#ragger","title":"Ragger","text":"<p>Make sure that you have already built the application for the specific device.</p> <p>Run Ragger tests:</p> <pre><code># Install python test suite dependencies\nbash$ pip install -r \"tests/python/requirements.txt\"\n\n# Run test suite for the specific device, e.g. nanos\nbash$ pytest tests/python/ --tb=short -v --device nanos -k \"\"\n</code></pre> <p>To regenerate golden snapshots, use <code>--golden_run</code> option.</p>"},{"location":"deps/app-solana/#integration","title":"Integration","text":"<p>First enable <code>blind-signing</code> in the App settings</p> <pre><code>bash$ cargo run --manifest-path tests/Cargo.toml\n</code></pre>"},{"location":"deps/app-solana/doc/api/","title":"Solana application : Common Technical Specifications","text":""},{"location":"deps/app-solana/doc/api/#140","title":"1.4.0","text":"<ul> <li>Add support of Trusted Name descriptor (checked by PKI certificate)</li> </ul>"},{"location":"deps/app-solana/doc/api/#131","title":"1.3.1","text":"<ul> <li>Add support for versioned messages</li> </ul>"},{"location":"deps/app-solana/doc/api/#130","title":"1.3.0","text":"<ul> <li>Add SIGN SOLANA OFF-CHAIN MESSAGE</li> <li>Add compatibility with the Exchange Application to SWAP, FUND, or SELL SOL tokens</li> </ul>"},{"location":"deps/app-solana/doc/api/#about","title":"About","text":"<p>This application describes the APDU messages interface to communicate with the Solana application.</p> <p>The application covers the following functionalities :</p> <ul> <li>Retrieve an address given an account number</li> <li>Sign Solana transaction</li> <li>Sign off-chain message</li> </ul> <p>The application interface can be accessed over HID or BLE</p>"},{"location":"deps/app-solana/doc/api/#general-purpose-apdus","title":"General purpose APDUs","text":""},{"location":"deps/app-solana/doc/api/#get-app-configuration","title":"GET APP CONFIGURATION","text":""},{"location":"deps/app-solana/doc/api/#description","title":"Description","text":"<p>This command returns specific application configuration</p>"},{"location":"deps/app-solana/doc/api/#command","title":"Command","text":"CLA INS P1 P2 Lc Le E0 04 00 00 00 04"},{"location":"deps/app-solana/doc/api/#input-data","title":"Input data","text":"<p>None</p>"},{"location":"deps/app-solana/doc/api/#output-data","title":"Output data","text":"Description Length Dummy setting n\u00b01 value 01 Dummy setting n\u00b02 value 01 Application major version 01 Application minor version 01 Application patch version 01"},{"location":"deps/app-solana/doc/api/#get-pubkey","title":"GET PUBKEY","text":""},{"location":"deps/app-solana/doc/api/#description_1","title":"Description","text":"<p>This command returns a Solana pubkey for the given BIP 32 path</p>"},{"location":"deps/app-solana/doc/api/#command_1","title":"Command","text":"CLA INS P1 P2 Lc Le E0 05 00 00 variable variable"},{"location":"deps/app-solana/doc/api/#input-data_1","title":"Input data","text":"Description Length Number of BIP 32 derivations to perform (3 or 4) 1 First derivation index (big endian) 4 ... 4 Last derivation index (big endian) 4"},{"location":"deps/app-solana/doc/api/#output-data_1","title":"Output data","text":"Description Length Pubkey 32"},{"location":"deps/app-solana/doc/api/#sign-solana-transaction","title":"SIGN SOLANA TRANSACTION","text":""},{"location":"deps/app-solana/doc/api/#description_2","title":"Description","text":"<p>This command signs a Solana Transaction after having the user validate the transaction-specific parameters:</p>"},{"location":"deps/app-solana/doc/api/#command_2","title":"Command","text":"CLA INS P1 P2 Lc Le E0 06 01 00 variable variable"},{"location":"deps/app-solana/doc/api/#input-data_2","title":"Input data","text":"Description Length Number of signers (derivation paths) (always 1) 1 Number of BIP 32 derivations to perform (2, 3 or 4) 1 First derivation index (big endian) 4 ... 4 Last derivation index (big endian) 4 Serialized transaction variable"},{"location":"deps/app-solana/doc/api/#output-data_2","title":"Output data","text":"Description Length Signature 64"},{"location":"deps/app-solana/doc/api/#sign-solana-off-chain-message","title":"SIGN SOLANA OFF-CHAIN MESSAGE","text":""},{"location":"deps/app-solana/doc/api/#description_3","title":"Description","text":"<p>This command signs a Solana Off-Chain Message after having the user validate the text of ASCII encoded messages, or hash of UTF-8 encoded messages:</p>"},{"location":"deps/app-solana/doc/api/#command_3","title":"Command","text":"CLA INS P1 P2 Lc Le E0 07 01 00 variable variable"},{"location":"deps/app-solana/doc/api/#input-data_3","title":"Input data","text":"Description Length Number of signers (derivation paths) (always 1) 1 Number of BIP 32 derivations to perform (2, 3 or 4) 1 First derivation index (big endian) 4 ... 4 Last derivation index (big endian) 4 Serialized off-chain message variable"},{"location":"deps/app-solana/doc/api/#output-data_3","title":"Output data","text":"Description Length Signature 64"},{"location":"deps/app-solana/doc/api/#get-challenge","title":"GET CHALLENGE","text":""},{"location":"deps/app-solana/doc/api/#description_4","title":"Description","text":"<p>_This command returns a 32-bit challenge generated by the app</p>"},{"location":"deps/app-solana/doc/api/#command_4","title":"Command","text":"CLA INS P1 P2 Lc Le E0 20 00 00 00 N/A"},{"location":"deps/app-solana/doc/api/#input-data_4","title":"Input data","text":"<p>N/A</p>"},{"location":"deps/app-solana/doc/api/#output-data_4","title":"Output data","text":"Description Length Challenge 4"},{"location":"deps/app-solana/doc/api/#provide-trusted-name-tlv-descriptor","title":"PROVIDE TRUSTED NAME TLV DESCRIPTOR","text":""},{"location":"deps/app-solana/doc/api/#description_5","title":"Description","text":"<p>_This command provides a Solana Trusted Name TLV descriptor</p>"},{"location":"deps/app-solana/doc/api/#command_5","title":"Command","text":"CLA INS P1 P2 Lc Le E0 21 00 00 F7 (max) variable"},{"location":"deps/app-solana/doc/api/#input-data_5","title":"Input data","text":"Description Length Serialized signed TLV descriptor payload variable"},{"location":"deps/app-solana/doc/api/#output-data_5","title":"Output data","text":"<p>N/A</p>"},{"location":"deps/app-solana/doc/api/#transport-protocol","title":"Transport protocol","text":""},{"location":"deps/app-solana/doc/api/#general-transport-description","title":"General transport description","text":"<p>Ledger APDUs requests and responses are encapsulated using a flexible protocol allowing to fragment large payloads over different underlying transport mechanisms.</p> <p>The common transport header is defined as follows:</p> Description Length Communication channel ID (big endian) 2 Command tag 1 Packet sequence index (big endian) 2 Payload var <p>The Communication channel ID allows commands multiplexing over the same physical link. It is not used for the time being, and should be set to 0101 to avoid compatibility issues with implementations ignoring a leading 00 byte.</p> <p>The Command tag describes the message content. Use TAG_APDU (0x05) for standard APDU payloads, or TAG_PING (0x02) for a simple link test.</p> <p>The Packet sequence index describes the current sequence for fragmented payloads. The first fragment index is 0x00.</p>"},{"location":"deps/app-solana/doc/api/#apdu-command-payload-encoding","title":"APDU Command payload encoding","text":"<p>APDU Command payloads are encoded as follows :</p> Description Length APDU length (big endian) 2 APDU CLA 1 APDU INS 1 APDU P1 1 APDU P2 1 APDU data length 1 Optional APDU data var <p>APDU payload is encoded according to the APDU case</p> Case Number Lc Le Case description 1 0 0 No data in either direction - L is set to 00 2 0 !0 Input Data present, no Output Data - L is set to Lc 3 !0 0 Output Data present, no Input Data - L is set to Le 4 !0 !0 Both Input and Output Data are present - L is set to Lc"},{"location":"deps/app-solana/doc/api/#deprecation-notice","title":"Deprecation notice","text":"<p>The <code>ADPU data length</code> field was formerly serialized as a 16bit unsigned big endian integer. As of version 0.2.0, this has been changed to an 8bit unsigned integer to improve compatibility with client libraries. In doing so, the following instructions have been deprecated.</p> <ul> <li>0x01 - GET_APP_CONFIGURATION</li> <li>0x02 - GET_PUBKEY</li> <li>0x03 - SIGN_MESSAGE</li> </ul>"},{"location":"deps/app-solana/doc/api/#apdu-response-payload-encoding","title":"APDU Response payload encoding","text":"<p>APDU Response payloads are encoded as follows :</p> Description Length APDU response length (big endian) 2 APDU response data and Status Word var"},{"location":"deps/app-solana/doc/api/#usb-mapping","title":"USB mapping","text":"<p>Messages are exchanged with the dongle over HID endpoints over interrupt transfers, with each chunk being 64 bytes long. The HID Report ID is ignored.</p>"},{"location":"deps/app-solana/doc/api/#ble-mapping","title":"BLE mapping","text":"<p>A similar encoding is used over BLE, without the Communication channel ID.</p> <p>The application acts as a GATT server defining service UUID D973F2E0-B19E-11E2-9E96-0800200C9A66</p> <p>When using this service, the client sends requests to the characteristic D973F2E2-B19E-11E2-9E96-0800200C9A66, and gets notified on the characteristic D973F2E1-B19E-11E2-9E96-0800200C9A66 after registering for it.</p> <p>Requests are encoded using the standard BLE 20 bytes MTU size</p>"},{"location":"deps/app-solana/doc/api/#status-words","title":"Status Words","text":"<p>The following standard Status Words are returned for all APDUs - some specific Status Words can be used for specific commands and are mentioned in the command description.</p>"},{"location":"deps/app-solana/doc/api/#status-words_1","title":"Status Words","text":"SW Description 6700 Incorrect length 6982 Security status not satisfied (Canceled by user) 6A80 Invalid data 6A81 Invalid off-chain message header 6A82 Invalid off-chain message format 6B00 Incorrect parameter P1 or P2 6Fxx Technical problem (Internal error, please report) 9000 Normal ending of the command"},{"location":"deps/app-solana/doc/fuzzing/","title":"Fuzzing","text":"<p>Building the fuzzer requires Clang and CMake.</p> <p>To quickly get started fuzzing Solana message parserusing libFuzzer:</p> <pre><code>cd fuzzing\n./build.sh\n./run.sh\n</code></pre> <p>Initial corpus has been generated from the testcases found in the <code>libsol</code> directory.</p>"},{"location":"deps/app-solana/doc/fuzzing/#code-coverage","title":"Code coverage","text":"<p>To generate a code coverage report of the fuzzer, it is possible to use <code>llvm-cov</code> (on Ubuntu: <code>sudo apt install llvm</code>):</p> <pre><code>cd fuzzing\n./coverage.sh\n</code></pre> <p>These commands generate a HTML report in <code>fuzzing/html-coverage/index.html</code>.</p>"},{"location":"deps/ledger-secure-sdk/","title":"Ledger Secure SDK","text":""},{"location":"deps/ledger-secure-sdk/#are-you-developing-an-application","title":"Are you developing an application?","text":"<p>If you are developing an application, for a smooth and quick integration: - See the developers\u2019 documentation on the Developer Portal - Go on Discord to chat with developer support and the developer community.</p>"},{"location":"deps/ledger-secure-sdk/#introduction","title":"Introduction","text":"<p>This directory contains the SDK for Nano S, Nano X, Nano S+, Stax, and Flex applications development.</p> <p>It is the unified version of the previous Nano S, Nano X, Nano S+ SDKs.</p> <p>As the previous SDKs, this SDK is tightly linked to the Ledger Hardware Wallet OS: BOLOS.</p> <p>Indeed, it allows to interact with <code>syscalls</code> and <code>cxlib</code> functions which are embedded in the OS.</p> <p>Hence you should make sure to use the right SDK version matching your development device OS.</p> <p>You can find below two possibilities to build against the right SDK version.</p>"},{"location":"deps/ledger-secure-sdk/#using-the-docker-image","title":"Using the docker image","text":"<p>The easiest way to build against last device OS is to use the docker image provided by ledger and accessible on ghcr.io.</p> <p>The corresponding GIT repository can be found here. Please have a look at its <code>README.md</code> for information about its usage.</p>"},{"location":"deps/ledger-secure-sdk/#using-the-sdk-directly-advanced-users","title":"Using the SDK directly (advanced users)","text":"<p>Advanced users that have setup the Ledger development environment can use this repository to build apps.</p> <p>But for that, they need to understand how OS and SDK compatibility are tracked. This is done with the <code>API_LEVEL</code> which is defined in <code>Makefile.defines</code>.</p> <p>The <code>API_LEVEL</code> on <code>master</code> branch is kept as the reserved value <code>0</code>.</p> <p>For each released OS there is a corresponding tag in the format <code>&lt;Device&gt;_&lt;os_version&gt;</code>, e.g. <code>NanoX_v2.1.0</code> for the release of the OS version <code>v2.1.0</code> for Nano X device. While on this tag, if you look at the value of the <code>API_LEVEL</code> which is defined in <code>Makefile.defines</code> you will retrieve the OS <code>API_LEVEL</code>.</p> <p>There are also <code>API_LEVEL_&lt;N&gt;</code> branches with <code>API_LEVEL</code> value set to <code>N</code>. Their purpose is to allow cherry-picks of bug fixes and improvements that are merged on <code>master</code> so that they are available when building the apps for the corresponding OS.</p> <p>On these <code>API_LEVEL_&lt;N&gt;</code> branches, there are tags following the format <code>v&lt;N&gt;.&lt;minor&gt;.&lt;patch&gt;</code>, e.g. <code>v1.1.0</code> where <code>N</code> is the <code>API_LEVEL</code>. These tags are used to generate the <code>SDK_VERSION</code> which is available at compile time and allows to track the SDK version used to build an app.</p> <p>The branch <code>API_LEVEL_LNS</code> tracks the sdk for the <code>NanoS_v2.1.0</code>. It's naming does not follow the <code>API_LEVEL_&lt;N&gt;</code> format because it is not a child of the branch <code>API_LEVEL_0</code>.</p> <p>In short, to build an app for an OS, you should: - Retrieve the OS <code>API_LEVEL</code>:     - <code>git checkout &lt;device&gt;_&lt;os_version&gt;</code>     - <code>grep API_LEVEL Makefile.defines | head -n1</code> - Check out the <code>API_LEVEL_&lt;N&gt;</code> branch related to the OS <code>API_LEVEL</code> and make sure it is up to date:     - <code>git checkout API_LEVEL_&lt;N&gt;</code>     - <code>git pull</code>     - The last commit should be tagged with the complete version of the SDK (<code>v&lt;N&gt;.&lt;x&gt;.&lt;y&gt;</code>) - Build the app from your app folder:     - <code>make BOLOS_SDK=&lt;path_to_sdk&gt; TARGET=&lt;target&gt;</code> where <code>target</code> is one of <code>nanos</code>, <code>nanox</code>, <code>nanos2</code>, <code>stax</code>, <code>flex</code> (<code>nanos2</code> is used for Nano S+ device).</p>"},{"location":"deps/ledger-secure-sdk/#about-api_level-branches","title":"About API_LEVEL branches","text":"<p>This list the main API_LEVEL branches with their purposed (corresponding OS) and state if they should still be patched or not (OS not \u201cactive\u201d anymore).</p> <p>The full mapping of API_LEVEL branches, including OS release candidates, is available here.</p> Name Related OS Active LNS  nanos_2.1.0 :heavy_check_mark: 1 nanox_2.1.0  nanos+_1.1.0 :x: 5 nanox_2.2.{0, 1, 2, 3}  nanos+ 1.1.1 :x: 8 stax_1.0.0 :x: 10 stax_1.1.0 :x: 11 stax_1.2.0  stax_1.2.1 :x: 13 stax_1.3.0 :x: 15 stax_1.4.0 :x: 18 nanos+_1.2.0 :x: 19 flex_1.0.0  flex_1.0.1  :x: 21 stax_1.5.0  flex_1.1.0  flex_1.1.1  :x: 22 nanox_2.4.1  nanos+_1.3.1  stax_1.6.1  flex_1.2.1  nanox_2.4.2  nanos+_1.3.2  stax_1.6.2  flex_1.2.2  :heavy_check_mark:"},{"location":"deps/ledger-secure-sdk/#cherry-picking-process","title":"Cherry-picking process:","text":"<ul> <li> <p>Fetch last changes from remote: <code>git fetch --all</code></p> </li> <li> <p>Create a new branch to hold your cherry-picks: <code>git checkout origin/API_LEVEL_X -b mybranch</code></p> </li> <li> <p>Cherry-pick your commits: <code>git cherry-pick -x commit_sha1</code> (the -x is useful to track the original commit of a cherry-pick).</p> </li> <li> <p>Push your branch: <code>git push origin mybranch</code></p> </li> <li> <p>Create a PR and indicate in it the PR where your cherry-pick where reviewed first.</p> </li> </ul>"},{"location":"deps/ledger-secure-sdk/#contributing","title":"Contributing","text":""},{"location":"deps/ledger-secure-sdk/#pre-commit","title":"Pre-commit","text":"<p>This repository uses pre-commit to identify simple programming issues at the time of code check-in.</p> <p>To enable pre-commit in your development environment:</p> <ol> <li> <p>Install pre-commit:</p> <pre><code>pip install pre-commit\n</code></pre> </li> <li> <p>Add pre-commit hooks</p> <pre><code>pre-commit install --hook-type pre-commit\npre-commit install --hook-type commit-msg\n</code></pre> </li> </ol>"},{"location":"deps/ledger-secure-sdk/#documentation","title":"Documentation","text":"<p>HTML documentation can be generated by typing:</p> <ul> <li>For Stax:</li> </ul> <p><code>make doc TARGET=stax</code></p> <ul> <li>For Nano X or Nano S+:</li> </ul> <p><code>make doc TARGET=nano</code></p> <p>from root directory</p> <p>The resulting documentation can be found in <code>build/doc/html/index.html</code></p> <p>If you have not already installed Doxygen, you can do it (on Linux-Ubuntu) with:</p> <pre><code>sudo apt-get install doxygen doxygen-doc graphviz\n</code></pre>"},{"location":"deps/ledger-secure-sdk/fuzzing/","title":"Fuzzing","text":""},{"location":"deps/ledger-secure-sdk/fuzzing/#manual-usage-based-on-ledger-container","title":"Manual usage based on Ledger container","text":""},{"location":"deps/ledger-secure-sdk/fuzzing/#preparation","title":"Preparation","text":"<p>The fuzzer can run from the docker <code>ledger-app-builder-legacy</code>. You can download it from the <code>ghcr.io</code> docker repository:</p> <pre><code>sudo docker pull ghcr.io/ledgerhq/ledger-app-builder/ledger-app-builder-legacy:latest\n</code></pre> <p>You can then enter this development environment by executing the following command from the repository root directory:</p> <pre><code>sudo docker run --rm -ti --user \"$(id -u):$(id -g)\" -v \"$(realpath .):/app\" ghcr.io/ledgerhq/ledger-app-builder/ledger-app-builder-legacy:latest\n</code></pre>"},{"location":"deps/ledger-secure-sdk/fuzzing/#compilation","title":"Compilation","text":"<p>Once in the container, go into the <code>fuzzing</code> folder to compile the fuzzer:</p> <pre><code>cd fuzzing\n\n# cmake initialization\ncmake -B build\n\n# Fuzzer compilation\nmake -C build\n</code></pre>"},{"location":"deps/ledger-secure-sdk/fuzzing/#run","title":"Run","text":"<pre><code>./build/fuzz_apdu_parser\n./build/fuzz_base58\n./build/fuzz_bip32\n./build/fuzz_qrcodegen\n</code></pre>"},{"location":"deps/ledger-secure-sdk/lib_nbgl/","title":"NBGL library","text":"<p>Graphic library for Stax</p>"},{"location":"deps/ledger-secure-sdk/lib_nbgl/serialization/","title":"Index","text":""},{"location":"deps/ledger-secure-sdk/lib_nbgl/serialization/#nbgl-serializationdeserialization-library","title":"NBGL serialization/deserialization library","text":""},{"location":"deps/ledger-secure-sdk/lib_nbgl/serialization/#usage","title":"Usage","text":"<p>Deserialize raw bytes into an Nbgl event: <pre><code>&gt;&gt;&gt; from nbgl_lib import deserialize_nbgl_bytes\n&gt;&gt;&gt; data = bytes.fromhex(\"00010501f403e800ff003201000301020403015465737420627574746f6e00\")\n&gt;&gt;&gt; nbgl_event = deserialize_nbgl_bytes(data)\n&gt;&gt;&gt; nbgl_event\nNbglDrawObjectEvent(obj=NbglButton(area=NbglArea(width=255, height=50, x0=500, y0=1000, background_color=&lt;NbglColor.DARK_GRAY: 1&gt;, bpp=&lt;NbglBpp.BPP_1: 0&gt;), inner_color=&lt;NbglColor.WHITE: 3&gt;, border_color=&lt;NbglColor.DARK_GRAY: 1&gt;, foreground_color=&lt;NbglColor.LIGHT_GRAY: 2&gt;, radius=&lt;NbglRadius.RADIUS_40_PIXELS: 4&gt;, font_id=&lt;NbglFontId.BAGL_FONT_HM_ALPHA_MONO_MEDIUM_32px: 3&gt;, localized=True, text='Test button'))\n</code></pre></p> <p>Serialize a Nbgl event into a json-like dict: <pre><code>&gt;&gt;&gt; from nbgl_lib import serialize_nbgl_json\n&gt;&gt;&gt; serialize_nbgl_json(nbgl_event)\n{'event': 'NBGL_DRAW_OBJ', 'obj': {'type': 'BUTTON', 'content': {'area': {'width': 255, 'height': 50, 'x0': 500, 'y0': 1000, 'background_color': 'DARK_GRAY', 'bpp': 'BPP_1'}, 'inner_color': 'WHITE', 'border_color': 'DARK_GRAY', 'foreground_color': 'LIGHT_GRAY', 'radius': 'RADIUS_40_PIXELS', 'font_id': 'BAGL_FONT_HM_ALPHA_MONO_MEDIUM_32px', 'localized': True, 'text': 'Test button'}}}\n</code></pre></p> <p>Deserialize json-like dict into an Nbgl event:</p> <pre><code>&gt;&gt;&gt; from nbgl_lib import deserialize_nbgl_json\n&gt;&gt;&gt; deserialize_nbgl_json({'event': 'NBGL_DRAW_OBJ', 'obj': {'type': 'BUTTON', 'content': {'area': {'width': 255, 'height': 50, 'x0': 500, 'y0': 1000, 'background_color': 'DARK_GRAY', 'bpp': 'BPP_1'}, 'inner_color': 'WHITE', 'border_color': 'DARK_GRAY', 'foreground_color': 'LIGHT_GRAY', 'radius': 'RADIUS_40_PIXELS', 'font_id': 'BAGL_FONT_HM_ALPHA_MONO_MEDIUM_32px', 'localized': True, 'text': 'Test button'}}})\nNbglDrawObjectEvent(obj=NbglButton(area=NbglArea(width=255, height=50, x0=500, y0=1000, background_color=&lt;NbglColor.DARK_GRAY: 1&gt;, bpp=&lt;NbglBpp.BPP_1: 0&gt;), inner_color=&lt;NbglColor.WHITE: 3&gt;, border_color=&lt;NbglColor.DARK_GRAY: 1&gt;, foreground_color=&lt;NbglColor.LIGHT_GRAY: 2&gt;, radius=&lt;NbglRadius.RADIUS_40_PIXELS: 4&gt;, font_id=&lt;NbglFontId.BAGL_FONT_HM_ALPHA_MONO_MEDIUM_32px: 3&gt;, localized=True, text='Test button'))\n</code></pre>"},{"location":"deps/ledger-secure-sdk/lib_nbgl/serialization/#tests","title":"Tests","text":"<ul> <li><code>generate_data_test.c</code> generates reference data for deserialization testing.</li> <li><code>test_bytes_deserialize.py</code> deserializes the reference data and inspect the result.</li> <li><code>test_json_ser_deser.py</code> tests json serialization and deserialization.</li> </ul> <p>To generate reference data and run tests:</p> <pre><code>make run_test\n</code></pre>"},{"location":"deps/ledger-secure-sdk/tests/screenshots/","title":"Screenshots generation","text":""},{"location":"deps/ledger-secure-sdk/tests/screenshots/#prerequisite","title":"Prerequisite","text":"<p>TBC</p>"},{"location":"deps/ledger-secure-sdk/tests/screenshots/#overview","title":"Overview","text":"<p>The goal of this mechanism is to generate screenshots of usual Applications scenarios.</p> <p>It can be used for any product (Stax, Flex, NanoX, NanoS+)</p>"},{"location":"deps/ledger-secure-sdk/tests/screenshots/#launch-screenshots-generation","title":"Launch screenshots generation","text":"<p>The screenshots generator can be built and launched in the same command, for a given product</p> <pre><code>make &lt;product&gt;_screenshots\n</code></pre> <p>where <code>&lt;product&gt;</code> can be:</p> <ul> <li><code>flex</code></li> <li><code>stax</code></li> <li><code>nanox</code></li> <li><code>nanosp</code></li> <li><code>apex_p</code></li> </ul> <p>so for example to generate screenshots for Flex:</p> <pre><code>make flex_screenshots\n</code></pre> <p>The result can be found in <code>build/&lt;product&gt;/screenshots</code></p>"},{"location":"deps/ledger-secure-sdk/tests/screenshots/#clean","title":"Clean","text":"<p>The environment can be cleaned-up with:</p> <pre><code>make &lt;product&gt;_clean\n</code></pre>"},{"location":"deps/ledger-secure-sdk/unit-tests/app_storage/","title":"Unit tests","text":""},{"location":"deps/ledger-secure-sdk/unit-tests/app_storage/#prerequisite","title":"Prerequisite","text":"<p>Be sure to have installed:</p> <ul> <li>CMake &gt;= 3.10</li> <li>CMocka &gt;= 1.1.5</li> </ul> <p>and for code coverage generation:</p> <ul> <li>lcov &gt;= 1.14</li> </ul>"},{"location":"deps/ledger-secure-sdk/unit-tests/app_storage/#overview","title":"Overview","text":"<p>In <code>unit-tests/app_storage</code> folder, compile with:</p> <pre><code>cmake -Bbuild -H. &amp;&amp; make -C build\n</code></pre> <p>and run tests with:</p> <pre><code>CTEST_OUTPUT_ON_FAILURE=1 make -C build test\n</code></pre>"},{"location":"deps/ledger-secure-sdk/unit-tests/app_storage/#generate-code-coverage","title":"Generate code coverage","text":"<p>Just execute in <code>unit-tests</code> folder</p> <pre><code>../gen_coverage.sh\n</code></pre> <p>it will output <code>coverage.total</code> and <code>coverage/</code> folder with HTML details (in <code>coverage/index.html</code>).</p>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_alloc/","title":"Dynamic Allocator Unit tests","text":""},{"location":"deps/ledger-secure-sdk/unit-tests/lib_alloc/#prerequisite","title":"Prerequisite","text":"<p>Be sure to have installed:</p> <ul> <li>CMake &gt;= 3.10</li> <li>CMocka &gt;= 1.1.5</li> </ul> <p>and for code coverage generation:</p> <ul> <li>lcov &gt;= 1.14</li> </ul>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_alloc/#overview","title":"Overview","text":"<p>In <code>unit-tests</code> folder, compile with:</p> <pre><code>cmake -Bbuild -H. &amp;&amp; make -C build\n</code></pre> <p>and run tests with:</p> <pre><code>CTEST_OUTPUT_ON_FAILURE=1 make -C build test\n</code></pre>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_alloc/#generate-code-coverage","title":"Generate code coverage","text":"<p>Just execute in <code>unit-tests</code> folder</p> <pre><code>../gen_coverage.sh\n</code></pre> <p>it will output <code>coverage.total</code> and <code>coverage/</code> folder with HTML details (in <code>coverage/index.html</code>).</p>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_nbgl/","title":"Unit tests","text":""},{"location":"deps/ledger-secure-sdk/unit-tests/lib_nbgl/#prerequisite","title":"Prerequisite","text":"<p>Be sure to have installed:</p> <ul> <li>CMake &gt;= 3.10</li> <li>CMocka &gt;= 1.1.5</li> </ul> <p>and for code coverage generation:</p> <ul> <li>lcov &gt;= 1.14</li> </ul>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_nbgl/#overview","title":"Overview","text":""},{"location":"deps/ledger-secure-sdk/unit-tests/lib_nbgl/#for-stax","title":"For Stax","text":"<p>In <code>unit-tests/lib_nbgl</code> folder, compile with:</p> <pre><code>STAX=1 cmake -Bbuild -H. &amp;&amp; make -C build\n</code></pre> <p>and run tests with:</p> <pre><code>CTEST_OUTPUT_ON_FAILURE=1 make -C build test\n</code></pre>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_nbgl/#for-nanos","title":"For Nanos","text":"<p>In <code>unit-tests</code> folder, compile with:</p> <pre><code>cmake -Bbuild -H. &amp;&amp; make -C build\n</code></pre> <p>and run tests with:</p> <pre><code>CTEST_OUTPUT_ON_FAILURE=1 make -C build test\n</code></pre>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_nbgl/#generate-code-coverage","title":"Generate code coverage","text":"<p>Just execute in <code>unit-tests</code> folder</p> <pre><code>../gen_coverage.sh\n</code></pre> <p>it will output <code>coverage.total</code> and <code>coverage/</code> folder with HTML details (in <code>coverage/index.html</code>).</p>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_standard_app/","title":"Unit tests","text":""},{"location":"deps/ledger-secure-sdk/unit-tests/lib_standard_app/#prerequisite","title":"Prerequisite","text":"<p>Be sure to have installed:</p> <ul> <li>CMake &gt;= 3.10</li> <li>CMocka &gt;= 1.1.5</li> </ul> <p>and for code coverage generation:</p> <ul> <li>lcov &gt;= 1.14</li> </ul>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_standard_app/#overview","title":"Overview","text":"<p>In <code>unit-tests/lib_standard_app</code> folder, compile with</p> <pre><code>cmake -Bbuild -H. &amp;&amp; make -C build\n</code></pre> <p>and run tests with</p> <pre><code>CTEST_OUTPUT_ON_FAILURE=1 make -C build test\n</code></pre>"},{"location":"deps/ledger-secure-sdk/unit-tests/lib_standard_app/#generate-code-coverage","title":"Generate code coverage","text":"<p>Just execute in <code>unit-tests</code> folder</p> <pre><code>../gen_coverage.sh\n</code></pre> <p>it will output <code>coverage.total</code> and <code>coverage/</code> folder with HTML details (in <code>coverage/index.html</code>).</p>"},{"location":"technical_informations/","title":"Technical Informations","text":"<p>Please find in this section technical information helpful for understanding the SWAP feature and thus helping you add the compatibility for it in your own Coin Application.</p> <p>Only technical information specific to the SWAP feature is written here.</p>"},{"location":"technical_informations/cal/","title":"Crypto Asset List (CAL)","text":"<p>The Crypto Asset List is there to tackle two issues:</p> <ul> <li>The Exchange application does not know which application to call to handle a given currency.</li> <li>The Coin application may not have all data on hand to handle a given currency.</li> </ul> <p>We solve these issues by using the CAL to give trusted information to the Exchange application.</p>"},{"location":"technical_informations/cal/#the-cal-signature","title":"The CAL signature","text":"<p>The data of the CAL is stored on a HSM alongside its signature.</p> <p>The signature is checked by the Exchange application upon reception of CAL data to ensure that the data is legitimate.</p> <p>In order to be able to test with dynamic data, the Exchange application can be compiled with the <code>TEST_PUBLIC_KEY=1</code> flag to accept a false Ledger HSM key. The resulting application will not work in production but is useful in our test framework.</p>"},{"location":"technical_informations/cal/#the-coin-configuration-format","title":"The coin configuration format","text":"<p>A coin configuration of a currency contains the following elements:</p> Bytes Description 1 byte Coin configuration length of the FROM coin. The coin configuration is made of the ticker, appname, and subconf 1 byte Ticker name length N N bytes Ticker name of this the coin configuration. The ticker has to be the same as the FROM ticker 1 byte Application name length M M bytes Name of the application that can handle this currency 1 byte Sub coin configuration length R R bytes Sub coin configuration, used for tokens to specify an app the subticker and the decimals S bytes Signature of the coin configuration by the Ledger key in DER format, curve secp256k1 hashfunc sha256 1 byte Packed derivation path length T T bytes Packed derivation path used for the FROM coin"},{"location":"technical_informations/cal/#the-subconfiguration","title":"The subconfiguration","text":"<p>The <code>subconfiguration</code> part is optional and is often used only when handling tokens.</p> <p>It's content is application specific, the bytes array will be given as pointer to the handles in the coin application, for more information about the handles please refer to the corresponding section Coin Application API</p> <p>A standard subconfiguration exists, it is composed of <code>ticker + decimals</code>, it is the one used by most of our applications when handling tokens (Ethereum and Solana for example).</p> <p>The Ragger tool provides utilities to craft coin configurations both without and with standard subconfiguration.</p> <p>As an example, here is the craft of the coin configuration for Solana in our tests:</p> <p>test/python/apps/solana_utils.py <pre><code>from ragger.utils import create_currency_config\nfrom ragger.bip import pack_derivation_path\n\n### Proposed Solana derivation paths for tests ###\n\nSOL_PACKED_DERIVATION_PATH      = pack_derivation_path(\"m/44'/501'/12345'\")\nSOL_PACKED_DERIVATION_PATH_2    = pack_derivation_path(\"m/44'/501'/0'/0'\")\n\n### Package this currency configuration in exchange format ###\n\n# Simple native currency configuration: Ticker + Appname\nSOL_CONF = create_currency_config(\"SOL\", \"Solana\")\n\n# Standard coin configuration for a token: Ticker + Appname + (Ticker + decimal)\nJUP_CONF = create_currency_config(\"JUP\", \"Solana\", (\"JUP\", 6))\nJUP_PACKED_DERIVATION_PATH = SOL_PACKED_DERIVATION_PATH\n\nSOL_USDC_CONF = create_currency_config(\"USDC\", \"Solana\", (\"USDC\", 6))\nSOL_USDC_PACKED_DERIVATION_PATH = SOL_PACKED_DERIVATION_PATH\n</code></pre></p> <p>test/python/apps/cal.py <pre><code># Solana and Solana tokens\nSOL_CURRENCY_CONFIGURATION = CurrencyConfiguration(ticker=\"SOL\", conf=SOL_CONF, packed_derivation_path=SOL_PACKED_DERIVATION_PATH)\nJUP_CURRENCY_CONFIGURATION = CurrencyConfiguration(ticker=\"JUP\", conf=JUP_CONF, packed_derivation_path=JUP_PACKED_DERIVATION_PATH)\nSOL_USDC_CURRENCY_CONFIGURATION = CurrencyConfiguration(ticker=\"USDC\", conf=SOL_USDC_CONF, packed_derivation_path=SOL_USDC_PACKED_DERIVATION_PATH)\n</code></pre></p>"},{"location":"technical_informations/dale/","title":"The DALE tool","text":"<p>The Dale tool can be used to translate in clear text the Exchange APDUs and RAPDUs.</p> <p>It is useful to understand what went wrong when encountering SWAP errors to understand better what went wrong.</p> <p>To use it, follow the README procedure in the Dale repository.</p> <p>https://github.com/LedgerHQ/dale</p>"},{"location":"technical_informations/diagram/","title":"Sequence diagram of a SWAP","text":"<p>This diagram showcases:</p> <ul> <li>The APDU and RAPDU exchanged between the Ledger Live and the Exchange application during a SWAP.</li> <li>The os_lib_calls commands made by the Exchange application to the involved Coin applications. </li> </ul> <p>Please look at the protocol documentation to know more about how the APDUs content.</p> <pre><code>sequenceDiagram\n    participant LL as Ledger Live\n    participant EA as Exchange App\n    participant TOCA as TO Coin App\n    participant FRCA as FROM Coin App\n    participant DS as Device Screen\n\n    LL-&gt;&gt;EA: START_NEW_TRANSACTION&lt;br/&gt;(0x03)\n    activate EA\n    EA--&gt;&gt;EA: Create a nonce for the transaction\n    EA--&gt;&gt;LL: Device Transaction ID (nonce)\n\n    LL-&gt;&gt;EA: SET_PARTNER_KEY&lt;br/&gt;(0x04)\n    EA--&gt;&gt;EA: Set the credentials of the exchange partner\n    EA--&gt;&gt;LL: return\n\n    LL-&gt;&gt;EA: CHECK_PARTNER&lt;br/&gt;(0x05)\n    EA--&gt;&gt;EA: Check that the credentials of the exchange&lt;br/&gt;partner are signed by the Ledger key\n    EA--&gt;&gt;LL: return\n\n    LL-&gt;&gt;EA: PROCESS_TRANSACTION_RESPONSE&lt;br/&gt;(0x06)\n    EA--&gt;&gt;EA: Receive and parse the transaction&lt;br/&gt;proposal from the exchange partner\n    EA--&gt;&gt;LL: return\n\n    LL-&gt;&gt;EA: CHECK_TRANSACTION_SIGNATURE&lt;br/&gt;(0x07)\n    EA--&gt;&gt;EA: Check that the transaction proposal&lt;br/&gt;is signed by the exchange partner\n    EA--&gt;&gt;LL: return\n\n    LL-&gt;&gt;EA: CHECK_PAYOUT_ADDRESS&lt;br/&gt;(0x08)\n    EA--&gt;&gt;TOCA: CHECK_ADDRESS os_lib_call()\n    activate TOCA\n    TOCA--&gt;&gt;TOCA: Check that the [payout] address is owned by the device\n    TOCA--&gt;&gt;EA: os_lib_end(): Result\n    deactivate TOCA\n    EA-&gt;&gt;TOCA: GET_PRINTABLE_AMOUNT os_lib_call()\n    activate TOCA\n    TOCA--&gt;&gt;TOCA: Format the receiving amount\n    TOCA--&gt;&gt;EA: os_lib_end(): Formatted amount\n    deactivate TOCA\n    EA--&gt;&gt;LL: return\n\n    LL-&gt;&gt;EA: CHECK_REFUND_ADDRESS_NO_DISPLAY&lt;br/&gt;(0x0C)\n    EA-&gt;&gt;FRCA: CHECK_ADDRESS os_lib_call()\n    activate FRCA\n    FRCA--&gt;&gt;FRCA: Check that the [refund] address belongs to the device\n    FRCA--&gt;&gt;EA: os_lib_end(): Result\n    deactivate FRCA\n    EA-&gt;&gt;FRCA: GET_PRINTABLE_AMOUNT os_lib_call()\n    activate FRCA\n    FRCA--&gt;&gt;FRCA: Format the sending amount\n    FRCA--&gt;&gt;EA: os_lib_end(): Formatted amount\n    deactivate FRCA\n    EA-&gt;&gt;FRCA: GET_PRINTABLE_AMOUNT os_lib_call()\n    activate FRCA\n    FRCA--&gt;&gt;FRCA: Format the fees amount\n    FRCA--&gt;&gt;EA: os_lib_end(): Formatted amount\n    deactivate FRCA\n    EA--&gt;&gt;LL: return\n\n    LL-&gt;&gt;EA: PROMPT_UI_DISPLAY&lt;br/&gt;(0x0F)\n    EA-&gt;&gt;DS: Request UI validation\n    activate DS\n    DS--&gt;&gt;DS: Display all the transaction data&lt;br/&gt;ask user to confirm\n    DS--&gt;&gt;EA: User confirmation\n    deactivate DS\n    EA--&gt;&gt;LL: return\n\n    LL-&gt;&gt;EA: START_SIGNING_TRANSACTION&lt;br/&gt;(0x0A)\n    EA--&gt;&gt;LL: Ok\n    EA-&gt;&gt;FRCA: SIGN_TRANSACTION os_lib_call()\n    activate FRCA\n    deactivate EA\n    FRCA--&gt;&gt;FRCA: Save data validated by the user\n    LL-&gt;&gt;FRCA: Sign transaction request\n    FRCA--&gt;&gt;FRCA: Check that the data to sign is the same&lt;br/&gt;as the data validated by the user + Sign\n    FRCA--&gt;&gt;LL: Signed transaction\n    FRCA--&gt;&gt;EA: os_lib_end()\n    deactivate FRCA\n    activate EA\n    EA--&gt;&gt;EA: Save last cycle data:&lt;br/&gt;Coin appname + sign status\n    EA--&gt;&gt;EA: Check if previous cycle\n    EA--&gt;&gt;DS: if previous cycle\n    activate DS\n    DS--&gt;&gt;DS: display sign status\n    DS--&gt;&gt;EA: \n    deactivate DS\n    deactivate EA</code></pre> <p>The FUND and SELL flows are not described as they are only subsets of the SWAP flow.</p>"},{"location":"technical_informations/protocol/","title":"EXCHANGE application protocol API","text":"<p>Communication is done through a series of request-response exchanges (APDU / RAPDU).</p> <p>Please look at the sequence diagram to know more about the APDUs used here.</p>"},{"location":"technical_informations/protocol/#request","title":"Request:","text":"Bytes Description 1 byte CLASS (constant 0xE0) 1 byte COMMAND to run 1 byte P1: RATE_TYPE of the transaction 1 byte P2: TYPE and EXTENSION 1 byte LC: Length of the data section LC bytes DATA, content depends of the COMMAND"},{"location":"technical_informations/protocol/#command","title":"COMMAND:","text":"Name Value Description GET_VERSION 0x02 Get application version. This APDU can be sent independently of the current app state START_NEW_TRANSACTION 0x03 Start new EXCHANGE transaction. This APDU resets the app state SET_PARTNER_KEY 0x04 Set the credentials of the exchange partner CHECK_PARTNER 0x05 Check that the credentials of the exchange partner are signed by the Ledger key PROCESS_TRANSACTION_RESPONSE 0x06 Receive the transaction proposal from the exchange partner CHECK_TRANSACTION_SIGNATURE 0x07 Check that the transaction proposal is signed by the exchange partner GET_CHALLENGE 0x10 Optional: Retrieve the current challenge value for the TLV trusted descriptor feature SEND_TRUSTED_NAME_DESCRIPTOR 0x11 Optional: Provide a TLV trusted descriptor CHECK_ASSET_IN_LEGACY_AND_DISPLAY 0x08 Format the amounts and fees used and prompts screen review (FUND_LEGACY and SELL_LEGACY flows only) CHECK_ASSET_IN_AND_DISPLAY 0x0B Format the amounts and fees used and prompts screen review (FUND based and SELL based flows) CHECK_ASSET_IN_NO_DISPLAY 0x0D Format the amounts and fees used. (FUND based and SELL based flows only) CHECK_PAYOUT_ADDRESS 0x08 Check that the payout address belongs to us (SWAP based flows only) CHECK_REFUND_ADDRESS_AND_DISPLAY 0x09 Check that the refund address belongs to us (SWAP based flows only) and prompts screen review CHECK_REFUND_ADDRESS_NO_DISPLAY 0x0C Check that the refund address belongs to us (SWAP based flows only) PROMPT_UI_DISPLAY 0x0F Prompt the screen review for the user START_SIGNING_TRANSACTION 0x0A Start the library application responsible for the FROM signing <p>The COMMANDS must be sent to the application in the correct order, this order depends of the TYPE chosen for the exchange flow:</p> All types START_NEW_TRANSACTION SET_PARTNER_KEY CHECK_PARTNER PROCESS_TRANSACTION_RESPONSE CHECK_TRANSACTION_SIGNATURE SWAP based TYPES or (discouraged version) FUND based and SELL based TYPES or (discouraged version) CHECK_PAYOUT_ADDRESS CHECK_PAYOUT_ADDRESS CHECK_ASSET_IN_NO_DISPLAY CHECK_ASSET_IN_AND_DISPLAY CHECK_REFUND_ADDRESS_NO_DISPLAY CHECK_REFUND_ADDRESS_AND_DISPLAY PROMPT_UI_DISPLAY PROMPT_UI_DISPLAY All types START_SIGNING_TRANSACTION"},{"location":"technical_informations/protocol/#notes-on-commands","title":"Notes on COMMANDS:","text":"<ul> <li> <p>Command START_SIGNING_TRANSACTION requires that a UI review by the user has happened, either through a CHECK_X_AND_DISPLAY (legacy method), or through the dedicated PROMPT_UI_DISPLAY command.</p> </li> <li> <p>It is always possible to restart the flow by sending a START_NEW_TRANSACTION command, except when the UI review screen is being displayed.</p> </li> <li> <p>The command START_SIGNING_TRANSACTION will start the library application, the current application will not be EXCHANGE anymore.</p> </li> </ul>"},{"location":"technical_informations/protocol/#rate_type","title":"RATE_TYPE:","text":"<p>Different possible rates for the transaction. The rate is sent to the app as P1 of an APDU.</p> Name Value Description FIXED 0x00 The rate in the transaction is a fixed value FLOATING 0x01 The rate in the transaction is an estimation"},{"location":"technical_informations/protocol/#type","title":"TYPE:","text":"<p>Different exchange types are possible for the app. The type is sent to the app as the lowest 4 bits of the P2 byte of the APDU.</p> <p>Changing the subcommand after an exchange flow is started will result in an error response and the APDU is ignored.</p> Name Value Description SWAP_LEGACY 0x00 SWAP transaction (crypto against crypto) using legacy signature and encoding, deprecated by the NEW counterpart SELL_LEGACY 0x01 SELL transaction (crypto against fiat) using legacy signature and encoding, deprecated by the NEW counterpart FUND_LEGACY 0x02 FUND transaction (crypto to owned account) using legacy signature and encoding, deprecated by the NEW counterpart SWAP_NEW 0x03 SWAP transaction (crypto against crypto) using unified signature and encoding SELL_NEW 0x04 SELL transaction (crypto against fiat) using unified signature and encoding FUND_NEW 0x05 FUND transaction (crypto to owned account) using unified signature and encoding"},{"location":"technical_informations/protocol/#extension","title":"EXTENSION:","text":"<p>This feature is only available in a PROCESS_TRANSACTION_RESPONSE command in a SWAP_NEW, SELL_NEW, or FUND_NEW flow.</p> <p>In Legacy flows the extension must be P2_NONE.</p> <p>The extension is sent to the app as the upper 4 bits of the P2 byte of the APDU.</p> <p>The maximum DATA in a single APDU is 255 bytes, in case it is not sufficient for a command, it is possible to use the EXTENSION feature to send the command in several parts.</p> <p>To use the EXTENSION feature, craft the data of the command you want to send and split it in 255 bytes chunks.</p> <p>Then send this chunks to the app using a combination of P2_EXTEND and P2_MORE in each APDU header.</p> <p>The application will reconstruct the DATA by concatenating the received APDUs.</p> <p>The application will refuse to reconstruct more than 512 bytes.</p> Name Value Description P2_NONE 0x00 &lt;&lt; 4 This APDU is self sufficient P2_EXTEND 0x01 &lt;&lt; 4 This APDU is not whole, it extends a previously received one P2_MORE 0x02 &lt;&lt; 4 This APDU is not whole, the followup part while be received later"},{"location":"technical_informations/protocol/#data","title":"DATA:","text":""},{"location":"technical_informations/protocol/#get_version","title":"GET_VERSION","text":"<p>No data expected.</p>"},{"location":"technical_informations/protocol/#start_new_transaction","title":"START_NEW_TRANSACTION","text":"<p>No data expected.</p>"},{"location":"technical_informations/protocol/#set_partner_key","title":"SET_PARTNER_KEY","text":""},{"location":"technical_informations/protocol/#for-all-legacy-types-the-data-for-this-command-is","title":"For all LEGACY TYPES, the data for this command is:","text":"Bytes Description 1 byte Length N of the encoded partner name N bytes Partner name encoded with utf-8 LC - (1 + N) bytes Partner public key"},{"location":"technical_informations/protocol/#for-all-unified-types-the-data-for-this-command-is","title":"For all UNIFIED TYPES, the data for this command is:","text":"Bytes Description 1 byte Length N of the encoded partner name N bytes Partner name encoded with utf-8 1 byte Curve used by the partner LC - (2 + N) bytes Partner public key <p>With the possible values for the curve being 0x00 for SECP256K1, and 0x01 for SECP256R1.</p>"},{"location":"technical_informations/protocol/#check_partner","title":"CHECK_PARTNER","text":"Bytes Description LC bytes Signature of the partner credentials by the Ledger key, curve secp256k1 hashfunc sha256"},{"location":"technical_informations/protocol/#process_transaction_response","title":"PROCESS_TRANSACTION_RESPONSE","text":"<p>Please refer to the src/protobuf files for the actual transaction proposal content.</p>"},{"location":"technical_informations/protocol/#for-all-legacy-types-the-data-for-this-command-is_1","title":"For all LEGACY TYPES, the data for this command is:","text":"Bytes Description 1 byte Length N of the encoded transaction proposal N bytes Transaction proposal. Bytes array for SWAP_LEGACY, URLsafe base 64 encoding for SELL_LEGACY and FUND_LEGACY 1 byte Length M of the transaction fees M bytes Transaction fees"},{"location":"technical_informations/protocol/#for-all-unified-types-the-data-for-this-command-is_1","title":"For all UNIFIED TYPES, the data for this command is:","text":"Bytes Description 1 byte Format used for the transaction encoding 2 bytes Length N of the encoded transaction proposal N bytes Encoded transaction proposal 1 byte Length M of the transaction fees M bytes Transaction fees <p>With the possible values for the format being 0x00 for Bytes Array (no encoding), and 0x01 for Base 64 Url encoding.</p> <p>The DATA of this command may exceed the capacity of a single APDU (255 bytes), in this case use the EXTENSION feature.</p>"},{"location":"technical_informations/protocol/#get_challenge","title":"GET_CHALLENGE","text":"<p>Retrieve the current challenge value for the TLV trusted descriptor feature.</p> <p>It will be regenerated on application side following a SEND_TRUSTED_NAME_DESCRIPTOR command (successful or not).</p>"},{"location":"technical_informations/protocol/#send_trusted_name_descriptor","title":"SEND_TRUSTED_NAME_DESCRIPTOR","text":"<p>Provide a TLV trusted descriptor from the CAL to apply a trusted value upon the refund or payout address.</p>"},{"location":"technical_informations/protocol/#check_transaction_signature","title":"CHECK_TRANSACTION_SIGNATURE","text":""},{"location":"technical_informations/protocol/#for-all-legacy-types-the-data-for-this-command-is_2","title":"For all LEGACY TYPES, the data for this command is:","text":"Bytes Description LC bytes Signature of the computed transaction proposed by the partner <p>For SWAP_LEGACY TYPE, the signature is computed on the transaction proposal.</p> <p>For SELL_LEGACY and FUND_LEGACY the signature is computed on the transaction proposal prefixed with a DOT ('.').</p> <p>For SWAP_LEGACY and FUND_LEGACY, the signature is in DER format.</p> <p>For SELL_LEGACY the signature is in (R,S) format.</p>"},{"location":"technical_informations/protocol/#for-all-unified-types-the-data-for-this-command-is_2","title":"For all UNIFIED TYPES, the data for this command is:","text":"Bytes Description 1 byte If the signature is computed on a prefixed transaction 1 byte Format of the signature itself LC - 2 bytes Signature of the computed transaction proposed by the partner <p>With the possible values for the format of the transaction used for signing being 0x01 if it was DOT ('.') prefixed, 0x00 otherwise.</p> <p>With the possible values for the format of the signature itself being 0x00 for DER format, and 0x01 for (R,S) format.</p>"},{"location":"technical_informations/protocol/#check_asset_in_legacy_and_display","title":"CHECK_ASSET_IN_LEGACY_AND_DISPLAY","text":"<p>This command is DEPRECATED.</p> <p>Please refer to CHECK_ASSET_IN_AND_DISPLAY (strict equivalent but discouraged) or CHECK_ASSET_IN_NO_DISPLAY + PROMPT_UI_DISPLAY</p> <p>This command works only for the SELL_LEGACY and FUND_LEGACY TYPES, the data content is the same as CHECK_ASSET_IN_AND_DISPLAY only the INS byte is different (and does not collide with CHECK_PAYOUT_ADDRESS).</p>"},{"location":"technical_informations/protocol/#check_asset_in_and_display","title":"CHECK_ASSET_IN_AND_DISPLAY","text":"<p>This command is the same as CHECK_ASSET_IN_NO_DISPLAY except that the application will prompt the UI review if the check is successful.</p> <p>Usage of this command is discouraged, please use CHECK_ASSET_IN_NO_DISPLAY + PROMPT_UI_DISPLAY instead.</p>"},{"location":"technical_informations/protocol/#check_asset_in_no_display","title":"CHECK_ASSET_IN_NO_DISPLAY","text":"<p>This command is used for SELL based and FUND based TYPES.</p> Bytes Description 1 byte Coin configuration length of the FROM coin. The coin configuration is made of the ticker, appname, and subconf 1 byte Ticker name length N N bytes Ticker name of this the coin configuration. The ticker has to be the same as the FROM ticker 1 byte Application name length M M bytes Name of the application that can handle this currency 1 byte Sub coin configuration length R R bytes Sub coin configuration, used for tokens to specify an app the subticker and the decimals S bytes Signature of the coin configuration by the Ledger key in DER format, curve secp256k1 hashfunc sha256 1 byte Packed derivation path length T T bytes Packed derivation path used for the FROM coin"},{"location":"technical_informations/protocol/#check_payout_address","title":"CHECK_PAYOUT_ADDRESS","text":"<p>This command is used only in the SWAP_LEGACY and SWAP_NEW TYPES.</p> Bytes Description 1 byte Coin configuration length of the TO coin. The coin configuration is made of the ticker, appname, and subconf 1 byte Ticker name length N N bytes Ticker name of this the coin configuration. The ticker has to be the same as the TO ticker 1 byte Application name length M M bytes Name of the application that can handle this currency 1 byte Sub coin configuration length R R bytes Sub coin configuration, used for tokens to specify an app the subticker and the decimals S bytes Signature of the coin configuration by the Ledger key in DER format, curve secp256k1 hashfunc sha256 1 byte Packed derivation path length T T bytes Packed derivation path used for the TO coin"},{"location":"technical_informations/protocol/#check_refund_address_and_display","title":"CHECK_REFUND_ADDRESS_AND_DISPLAY","text":"<p>This command is the same as CHECK_REFUND_ADDRESS_NO_DISPLAY except that the application will prompt the UI review if the check is successful.</p> <p>Usage of this command is discouraged, please use CHECK_REFUND_ADDRESS_NO_DISPLAY + PROMPT_UI_DISPLAY instead.</p>"},{"location":"technical_informations/protocol/#check_refund_address_no_display","title":"CHECK_REFUND_ADDRESS_NO_DISPLAY","text":"<p>This command is used only in the SWAP_LEGACY and SWAP_NEW TYPES.</p> Bytes Description 1 byte Coin configuration length of the FROM coin. The coin configuration is made of the ticker, appname, and subconf 1 byte Ticker name length N N bytes Ticker name of this the coin configuration. The ticker has to be the same as the FROM ticker 1 byte Application name length M M bytes Name of the application that can handle this currency 1 byte Sub coin configuration length R R bytes Sub coin configuration, used for tokens to specify an app the subticker and the decimals S bytes Signature of the coin configuration by the Ledger key in DER format, curve secp256k1 hashfunc sha256 1 byte Packed derivation path length T T bytes Packed derivation path used for the FROM coin"},{"location":"technical_informations/protocol/#prompt_ui_display","title":"PROMPT_UI_DISPLAY","text":"<p>This command prompts the UI so the user can validate the transaction on screen.</p>"},{"location":"technical_informations/protocol/#start_signing_transaction","title":"START_SIGNING_TRANSACTION","text":"<p>No data expected.</p>"},{"location":"technical_informations/protocol/#response","title":"Response:","text":"Bytes Description N bytes Command specific data 2 bytes Return code"},{"location":"technical_informations/protocol/#returned-data","title":"Returned data","text":"<p>Only the COMMANDS described below return data. All others only return a code.</p>"},{"location":"technical_informations/protocol/#get_version_1","title":"GET_VERSION","text":"<p>In case of success, this command will return the application version in format {MAJOR.MINOR.PATCH}.</p>"},{"location":"technical_informations/protocol/#start_new_transaction_1","title":"START_NEW_TRANSACTION","text":"<p>In case of success, this command will return a nonce called \"device transaction id\" used for the initiated flow.</p> <p>For TYPE SWAP_LEGACY, the format of this nonce is a 10 char array.</p> <p>For all other TYPES, the format of this nonce is a 32 bytes array.</p>"},{"location":"technical_informations/protocol/#get_challenge_1","title":"GET_CHALLENGE","text":"<p>The current challenge value in u32 format.</p>"},{"location":"technical_informations/protocol/#return-code","title":"Return code","text":"<p>Return code can be one of the following values:</p> Bytes Name Description 0x6A80 INCORRECT_COMMAND_DATA The DATA sent does not match the correct format for the COMMAND specified 0x6A81 DESERIALIZATION_FAILED Can't parse partner transaction proposal 0x6A82 WRONG_TRANSACTION_ID Transaction ID is not equal to one generated on the START_NEW_TRANSACTION step 0x6A83 INVALID_ADDRESS Refund or payout address doesn't belong to us 0x6A84 USER_REFUSED User refused the transaction proposal 0x6A85 INTERNAL_ERROR Internal error of the application 0x6A86 WRONG_P1 The P1 value is not a valid RATE 0x6A87 WRONG_P2_SUBCOMMAND The P2 lower 4 bits of the P2 byte is not a valid SUBCOMMAND 0x6A88 WRONG_P2_EXTENSION The P2 upper 4 bits of the P2 byte is not a valid EXTENSION 0x6A89 INVALID_P2_EXTENSION The extension is a valid value but is refused in the current context 0x6A8A MEMORY_CORRUPTION A child application started by Exchange has corrupted the Exchange application memory 0x6A8B AMOUNT_FORMATTING_FAILED A child application failed to format an amount provided by the partner 0x6A8C APPLICATION_NOT_INSTALLED The requested child application is not installed on the device 0x6A8D WRONG_EXTRA_ID_OR_EXTRA_DATA The values given for extra_id (memo) and / or extra_data (Thorswap like) are incorrect 0x6A8E WRONG_TLV_CHALLENGE The challenge provided in the descriptor does not match the challenge generated 0x6A8F WRONG_TLV_CONTENT The content of the descriptor does not fit the Exchange use case specification 0x6A90 MISSING_TLV_CONTENT The descriptor is missing requirement tags 0x6A91 WRONG_TRUSTED_NAME_TLV The content of the descriptor does not fit the common descriptor specification 0x6E00 CLASS_NOT_SUPPORTED The CLASS is not 0xE0 0x6E01 MALFORMED_APDU The APDU header is malformed 0x6E02 INVALID_DATA_LENGTH The length of the DATA is refused for this COMMAND 0x6D00 INVALID_INSTRUCTION COMMAND is not in the \"Possible commands\" table 0x6D01 UNEXPECTED_INSTRUCTION COMMAND is in the \"Possible commands\" table but is refused in the current context 0x6D02 DESCRIPTOR_NOT_USED The received descriptor could not be applied to refund nor payout address 0x9D1A SIGN_VERIFICATION_FAIL The signature sent by this command does not match the data or the associated public key 0x9000 SUCCESS Success code"},{"location":"technical_informations/coin_application_api/","title":"Coin Application API","text":"<p>The handle functions must be defined by each Coin application implementing the SWAP feature.</p> <p>Handlers are called by Exchange through the <code>os_lib_call</code> API, and dispatched by the <code>main()</code> and <code>library_app_main()</code> functions of the lib_standard_app.</p> <p>The Exchange application is responsible for handling the flow and sequencing of the SWAP.</p> <p><code>ledger-secure-sdk/lib_standard_app/main.c</code> <pre><code>/* This function is called by the main() function if this application was started by Exchange\n * through an os_lib_call() as opposed to being started from the Dashboard.\n *\n * We dispatch the Exchange request to the correct handler.\n * Handlers content are not defined in the `lib_standard_app`\n */\nWEAK void library_app_main(libargs_t *args)\n{\n    BEGIN_TRY\n    {\n        TRY\n        {\n            PRINTF(\"Inside library\\n\");\n            switch (args-&gt;command) {\n                case SIGN_TRANSACTION: {\n                    // Backup up transaction parameters and wipe BSS to avoid collusion with\n                    // app-exchange BSS data.\n                    bool success = swap_copy_transaction_parameters(args-&gt;create_transaction);\n                    if (success) {\n                        // BSS was wiped, we can now init these globals\n                        G_called_from_swap    = true;\n                        G_swap_response_ready = false;\n                        // Keep the address at which we'll reply the signing status\n                        G_swap_signing_return_value_address = &amp;args-&gt;create_transaction-&gt;result;\n\n                        common_app_init();\n\n#ifdef HAVE_NBGL\n                        nbgl_useCaseSpinner(\"Signing\");\n#endif  // HAVE_NBGL\n\n                        app_main();\n                    }\n                    break;\n                }\n                case CHECK_ADDRESS:\n                    swap_handle_check_address(args-&gt;check_address);\n                    break;\n                case GET_PRINTABLE_AMOUNT:\n                    swap_handle_get_printable_amount(args-&gt;get_printable_amount);\n                    break;\n                default:\n                    break;\n            }\n        }\n        CATCH_OTHER(e)\n        {\n            (void) e;\n            PRINTF(\"Exiting following exception: 0x%04X\\n\", e);\n        }\n        FINALLY\n        {\n            os_lib_end();\n        }\n    }\n    END_TRY;\n}\n</code></pre></p>"},{"location":"technical_informations/coin_application_api/error_codes/","title":"Error responses for applications started by Exchange in SWAP context","text":"<p>This specification applies to the error responses returned by the Coin applications when started by Exchange for the final payment transaction of a SWAP.</p> <p>Replying valuable data when a final payment transaction is refused eases a lot the analysis, especially if the issue happens in production context and / or is hard to reproduce.</p>"},{"location":"technical_informations/coin_application_api/error_codes/#rapdu-status-word","title":"RAPDU status word","text":"<p>Each application must define a unique status word for every Exchange-related error.</p>"},{"location":"technical_informations/coin_application_api/error_codes/#rapdu-data","title":"RAPDU data","text":"<p>The first 2 bytes of the RAPDU data represent the error code. Format is 16 bits integer in big endian.</p> <p>The upper byte is common between all applications. It must be one of the following value:</p> Name Value Description ERROR_INTERNAL 0x00 Internal application error, forward to the Firmware team for analysis. ERROR_WRONG_AMOUNT 0x01 The amount does not match the one validated in Exchange. ERROR_WRONG_DESTINATION 0x02 The destination address does not match the one validated in Exchange. ERROR_WRONG_FEES 0x03 The fees are different from what was validated in Exchange. ERROR_WRONG_METHOD 0x04 The method used is invalid in Exchange context. ERROR_CROSSCHAIN_WRONG_MODE 0x05 The mode used for the cross-chain hash validation is not supported. ERROR_CROSSCHAIN_WRONG_METHOD 0x06 The method used is invalid in cross-chain Exchange context. ERROR_CROSSCHAIN_WRONG_HASH 0x07 The hash for the cross-chain transaction does not match the validated value. ERROR_GENERIC 0xFF A generic or unspecified error not covered by the specific error codes above.Refer to the remaining bytes for further details on the error. <p>The lower byte can be set by the application to refine the error code returned.</p> <p>So the error code for <code>ERROR_WRONG_METHOD</code> would be <code>0x04XX</code> with <code>XX</code> being application specific (can be <code>00</code> if there is nothing to refine).</p> <p>The remaining bytes of the data are application-specific and can include, but are not limited to:</p> <ul> <li>Debugging information (e.g., error logs or internal state).</li> <li>Field values (e.g., expected vs actual amounts, destination, fees).</li> <li>More specific error codes tailored to the application's context.</li> </ul> <p>The standard application library define several helper function to return error codes from the Coin application.</p> <p><code>ledger-secure-sdk/lib_standard_app/swap_error_code_helpers.h</code> <pre><code>/**\n * Sends a basic swap error with no extra data.\n *\n * @param status_word RAPDU status word.\n * @param common_error_code Common error code defined in swap_error_common_code_t.\n * @param application_specific_error_code Application-specific error code.\n */\n__attribute__((noreturn)) void send_swap_error_simple(uint16_t status_word,\n                                                      uint8_t  common_error_code,\n                                                      uint8_t  application_specific_error_code);\n\n/**\n * Sends a swap error with one additional buffer data.\n *\n * @param status_word RAPDU status word.\n * @param common_error_code Common error code.\n * @param application_specific_error_code Application-specific error code.\n * @param buffer_data Additional application-specific error details.\n */\n__attribute__((noreturn)) void send_swap_error_with_buffer(uint16_t status_word,\n                                                           uint8_t  common_error_code,\n                                                           uint8_t  application_specific_error_code,\n                                                           const buffer_t buffer_data);\n\n/**\n * Sends a swap error with multiple buffers containing error details as data.\n *\n * @param status_word RAPDU status word.\n * @param common_error_code Common error code.\n * @param application_specific_error_code Application-specific error code.\n * @param buffer_data Array of buffers with error details. SWAP_ERROR_HELPER_MAX_BUFFER_COUNT\n * @param count Number of buffers provided.\n */\n#define SWAP_ERROR_HELPER_MAX_BUFFER_COUNT 8\n__attribute__((noreturn)) void send_swap_error_with_buffers(uint16_t status_word,\n                                                            uint8_t  common_error_code,\n                                                            uint8_t application_specific_error_code,\n                                                            const buffer_t *buffer_data,\n                                                            size_t          count);\n\n/**\n * Macro to send a swap error with a formatted string as data.\n *\n * Constructs a buffer from a formatted string and passes it to send_swap_error_with_buffers.\n * @param status_word RAPDU status word.\n * @param common_error_code Common error code.\n * @param application_specific_error_code Application-specific error code.\n * @param format printf-style format string.\n * @param ... Additional arguments for formatting.\n */\n// Immediately call snprintf here (no function wrapping it cleanly in a .c file).\n// This is because we don't have a vsnprintf implementation which would be needed if\n// we were to pass the va_args to an intermediate function.\n// See https://stackoverflow.com/a/150578\n#define send_swap_error_with_string(                                                             \\\n    status_word, common_error_code, application_specific_error_code, format, ...)                \\\n    do {                                                                                         \\\n        /* Up to a full data apdu minus the status word and the swap error code */               \\\n        char format_buffer[sizeof(G_io_apdu_buffer) - sizeof(status_word) - 2] = {0};            \\\n        /* snprintf always returns 0 on our platform, don't check the return value */            \\\n        /* See https://github.com/LedgerHQ/ledger-secure-sdk/issues/236 */                       \\\n        snprintf(format_buffer, sizeof(format_buffer), format, ##__VA_ARGS__);                   \\\n        PRINTF(\"send_swap_error_with_string %s\\n\", format_buffer);                               \\\n        buffer_t string_buffer;                                                                  \\\n        string_buffer.ptr    = (uint8_t *) &amp;format_buffer;                                       \\\n        string_buffer.size   = strnlen(format_buffer, sizeof(format_buffer));                    \\\n        string_buffer.offset = 0;                                                                \\\n        send_swap_error_with_buffers(                                                            \\\n            status_word, common_error_code, application_specific_error_code, &amp;string_buffer, 1); \\\n    } while (0)\n</code></pre></p>"},{"location":"technical_informations/coin_application_api/swap_copy_transaction_parameters/","title":"swap_copy_transaction_parameters()","text":"<p><code>ledger-secure-sdk/lib_standard_app/swap_entrypoints.h</code> <pre><code>/* This handle is called when the user has validated on screen the transaction\n * proposal sent by the partner and started the FROM Coin application to sign\n * the payment transaction.\n *\n * This handler needs to save in the heap the details of what has been validated\n * in Exchange. These elements will be checked against the received transaction\n * upon its reception from the Ledger Live.\n *\n * return false on error, true otherwise\n */\nbool swap_copy_transaction_parameters(create_transaction_parameters_t *sign_transaction_params);\n</code></pre></p> <p><code>ledger-secure-sdk/lib_standard_app/swap_lib_calls.h</code> <pre><code>typedef struct create_transaction_parameters_s {\n    // INPUTS //\n    // Additional data when dealing with tokens\n    // Content is coin application specific\n    uint8_t *coin_configuration;\n    uint8_t  coin_configuration_length;\n\n    // The amount validated on the screen by the user\n    uint8_t *amount;\n    uint8_t  amount_length;\n\n    // The fees amount validated on the screen by the user\n    uint8_t *fee_amount;\n    uint8_t  fee_amount_length;\n\n    // The partner address that will receive the funds\n    char *destination_address;\n    char *destination_address_extra_id;\n\n    // OUTPUT //\n    // /!\\ This parameter is handled by the lib_standard_app, DO NOT interact\n    // with it in the Coin application\n    //\n    // After reception and signature or refusal of the transaction, the Coin\n    // application will return to Exchange. This boolean is used to inform the\n    // Exchange application of the result.\n    // Set to 1 if the transaction was successfully signed, 0 otherwise.\n    uint8_t result;\n} create_transaction_parameters_t;\n</code></pre></p>"},{"location":"technical_informations/coin_application_api/swap_copy_transaction_parameters/#example-of-handle-implementation-in-solana","title":"Example of handle implementation in Solana","text":"<p><code>app-solana/src/swap/handle_swap_sign_transaction.c</code> <pre><code>#include \"handle_swap_sign_transaction.h\"\n#include \"utils.h\"\n#include \"os.h\"\n#include \"swap_lib_calls.h\"\n#include \"swap_utils.h\"\n#include \"sol/printer.h\"\n#include \"swap_common.h\"\n#include \"util.h\"\n\ntypedef struct swap_validated_s {\n    bool initialized;\n    uint8_t decimals;\n    char ticker[MAX_SWAP_TOKEN_LENGTH];\n    uint64_t amount;\n    uint64_t fee;\n    char recipient[BASE58_PUBKEY_LENGTH];\n} swap_validated_t;\n\nstatic swap_validated_t G_swap_validated;\n\n// Save the BSS address where we will write the return value when finished\nstatic uint8_t *G_swap_sign_return_value_address;\n\n// Save the data validated during the Exchange app flow\nbool copy_transaction_parameters(create_transaction_parameters_t *params) {\n    // Ensure no extraid\n    if (params-&gt;destination_address_extra_id == NULL) {\n        PRINTF(\"destination_address_extra_id expected\\n\");\n        return false;\n    } else if (params-&gt;destination_address_extra_id[0] != '\\0') {\n        PRINTF(\"destination_address_extra_id expected empty, not '%s'\\n\",\n               params-&gt;destination_address_extra_id);\n        return false;\n    }\n\n    // first copy parameters to stack, and then to global data.\n    // We need this \"trick\" as the input data position can overlap with app globals\n    swap_validated_t swap_validated;\n    memset(&amp;swap_validated, 0, sizeof(swap_validated));\n\n    // Parse config and save decimals and ticker\n    // If there is no coin_configuration, consider that we are doing a SOL swap\n    if (params-&gt;coin_configuration == NULL) {\n        memcpy(swap_validated.ticker, \"SOL\", sizeof(\"SOL\"));\n        swap_validated.decimals = SOL_DECIMALS;\n    } else {\n        if (!swap_parse_config(params-&gt;coin_configuration,\n                               params-&gt;coin_configuration_length,\n                               swap_validated.ticker,\n                               sizeof(swap_validated.ticker),\n                               &amp;swap_validated.decimals)) {\n            PRINTF(\"Fail to parse coin_configuration\\n\");\n            return false;\n        }\n    }\n\n    // Save recipient\n    strlcpy(swap_validated.recipient,\n            params-&gt;destination_address,\n            sizeof(swap_validated.recipient));\n    if (swap_validated.recipient[sizeof(swap_validated.recipient) - 1] != '\\0') {\n        PRINTF(\"Address copy error\\n\");\n        return false;\n    }\n\n    // Save amount\n    if (!swap_str_to_u64(params-&gt;amount, params-&gt;amount_length, &amp;swap_validated.amount)) {\n        return false;\n    }\n\n    // Save amount\n    if (!swap_str_to_u64(params-&gt;fee_amount, params-&gt;fee_amount_length, &amp;swap_validated.fee)) {\n        return false;\n    }\n\n    swap_validated.initialized = true;\n\n    // Full reset the global variables\n    os_explicit_zero_BSS_segment();\n\n    // Keep the address at which we'll reply the signing status\n    G_swap_sign_return_value_address = &amp;params-&gt;result;\n\n    // Commit the values read from exchange to the clean global space\n    memcpy(&amp;G_swap_validated, &amp;swap_validated, sizeof(swap_validated));\n    return true;\n}\n</code></pre></p>"},{"location":"technical_informations/coin_application_api/swap_handle_check_address/","title":"swap_handle_check_address()","text":"<p><code>ledger-secure-sdk/lib_standard_app/swap_entrypoints.h</code> <pre><code>/* This handle is called when the Exchange application wants to ensure that a\n * given address belongs to the device.\n *\n * If the address does belong to the device, result is set to 1. Otherwise it\n * is set to 0.\n */\nvoid swap_handle_check_address(check_address_parameters_t *params);\n</code></pre></p> <p><code>ledger-secure-sdk/lib_standard_app/swap_lib_calls.h</code> <pre><code>typedef struct check_address_parameters_s {\n    // INPUTS //\n    // Additional data when dealing with tokens\n    // Content is coin application specific\n    uint8_t *coin_configuration;\n    uint8_t  coin_configuration_length;\n\n    // serialized path, segwit, version prefix, hash used, dictionary etc.\n    // fields and serialization format are coin application specific\n    uint8_t *address_parameters;\n    uint8_t  address_parameters_length;\n\n    // The address to check\n    char *address_to_check;\n\n    // Extra content that may be relevant depending on context: memo, calldata, ...\n    // Content is coin application specific\n    char *extra_id_to_check;\n\n    // OUTPUT //\n    // Set to 1 if the address belongs to the device. 0 otherwise.\n    int result;\n} check_address_parameters_t;\n</code></pre></p>"},{"location":"technical_informations/coin_application_api/swap_handle_check_address/#example-of-handle-implementation-in-solana","title":"Example of handle implementation in Solana","text":"<p><code>app-solana/src/swap/handle_check_address.c</code> <pre><code>#include &lt;string.h&gt;\n\n#include \"handle_check_address.h\"\n#include \"os.h\"\n#include \"utils.h\"\n#include \"sol/printer.h\"\n\n// Helper to get our public key in base58 format for a given derivation path\nstatic int derive_public_key(const uint8_t *buffer,\n                             uint16_t buffer_length,\n                             uint8_t public_key[PUBKEY_LENGTH],\n                             char public_key_str[BASE58_PUBKEY_LENGTH]) {\n    uint32_t derivation_path[MAX_BIP32_PATH_LENGTH];\n    uint32_t path_length;\n    int ret;\n\n    ret = read_derivation_path(buffer, buffer_length, derivation_path, &amp;path_length) != 0;\n    if (ret != 0) {\n        return ret;\n    }\n\n    get_public_key(public_key, derivation_path, path_length);\n\n    return encode_base58(public_key, PUBKEY_LENGTH, public_key_str, BASE58_PUBKEY_LENGTH);\n}\n\n// Check that params-&gt;address_to_check belongs to us on derivation path params-&gt;address_parameters\nvoid swap_handle_check_address(check_address_parameters_t *params) {\n    PRINTF(\"Inside Solana swap_handle_check_address\\n\");\n    // ensure result is zero even if an exception is thrown\n    params-&gt;result = 0;\n    PRINTF(\"Params on the address %d\\n\", (unsigned int) params);\n\n    if (params-&gt;address_parameters == NULL) {\n        PRINTF(\"derivation path expected\\n\");\n        return;\n    }\n\n    if (params-&gt;address_to_check == NULL) {\n        PRINTF(\"Address to check expected\\n\");\n        return;\n    }\n    PRINTF(\"Address to check %s\\n\", params-&gt;address_to_check);\n\n    if (params-&gt;extra_id_to_check == NULL) {\n        PRINTF(\"extra_id_to_check expected\\n\");\n        return;\n    } else if (params-&gt;extra_id_to_check[0] != '\\0') {\n        PRINTF(\"extra_id_to_check expected empty, not '%s'\\n\", params-&gt;extra_id_to_check);\n        return;\n    }\n\n    uint8_t public_key[PUBKEY_LENGTH];\n    char public_key_str[BASE58_PUBKEY_LENGTH];\n    if (derive_public_key(params-&gt;address_parameters,\n                          params-&gt;address_parameters_length,\n                          public_key,\n                          public_key_str) != 0) {\n        PRINTF(\"Failed to derive public key\\n\");\n        return;\n    }\n    // Only public_key_str is useful in this context\n    UNUSED(public_key);\n\n    if (strcmp(params-&gt;address_to_check, public_key_str) != 0) {\n        PRINTF(\"Address %s != %s\\n\", params-&gt;address_to_check, public_key_str);\n        return;\n    }\n\n    PRINTF(\"Addresses match\\n\");\n    params-&gt;result = 1;\n}\n</code></pre></p>"},{"location":"technical_informations/coin_application_api/swap_handle_get_printable_amount/","title":"swap_handle_get_printable_amount()","text":"<p><code>ledger-secure-sdk/lib_standard_app/swap_entrypoints.h</code> <pre><code>/* This handle is called when the Exchange application wants to format for\n * display an amount + ticker of a currency known by this application\n *\n * If the formatting succeeds, result is set to the formatted string. Otherwise\n * it is set to '\\0'.\n */\nvoid swap_handle_get_printable_amount(get_printable_amount_parameters_t *params);\n</code></pre></p> <p><code>ledger-secure-sdk/lib_standard_app/swap_lib_calls.h</code> <pre><code>typedef struct get_printable_amount_parameters_s {\n    // INPUTS //\n    // Additional data when dealing with tokens\n    // Content is coin application specific\n    uint8_t *coin_configuration;\n    uint8_t  coin_configuration_length;\n\n    // Raw amount in big number format\n    uint8_t *amount;\n    uint8_t  amount_length;\n\n    // Set to true if the amount to format is the fee of the swap.\n    bool is_fee;\n\n    // OUTPUT //\n    // Set to the formatted string if the formatting succeeds. 0 otherwise.\n    char printable_amount[MAX_PRINTABLE_AMOUNT_SIZE];\n} get_printable_amount_parameters_t;\n</code></pre></p>"},{"location":"technical_informations/coin_application_api/swap_handle_get_printable_amount/#example-of-handle-implementation-in-solana","title":"Example of handle implementation in Solana","text":"<p><code>app-solana/src/swap/handle_get_printable_amount.c</code> <pre><code>#include \"handle_get_printable_amount.h\"\n#include \"swap_lib_calls.h\"\n#include \"swap_utils.h\"\n#include \"utils.h\"\n#include \"sol/printer.h\"\n#include \"swap_common.h\"\n\nvoid swap_handle_get_printable_amount(get_printable_amount_parameters_t *params) {\n    PRINTF(\"Inside Solana swap_handle_get_printable_amount\\n\");\n    MEMCLEAR(params-&gt;printable_amount);\n\n    uint64_t amount;\n    if (!swap_str_to_u64(params-&gt;amount, params-&gt;amount_length, &amp;amount)) {\n        PRINTF(\"Amount is too big\\n\");\n        return;\n    }\n\n    // Fees are displayed normally\n    if (params-&gt;is_fee || params-&gt;coin_configuration == NULL) {\n        PRINTF(\"Defaulting to native SOL amount\\n\");\n        if (print_amount(amount, params-&gt;printable_amount, sizeof(params-&gt;printable_amount)) != 0) {\n            PRINTF(\"print_amount failed\\n\");\n            return;\n        }\n    } else {\n        uint8_t decimals;\n        char ticker[MAX_SWAP_TOKEN_LENGTH] = {0};\n        if (!swap_parse_config(params-&gt;coin_configuration,\n                               params-&gt;coin_configuration_length,\n                               ticker,\n                               sizeof(ticker),\n                               &amp;decimals)) {\n            PRINTF(\"Fail to parse coin_configuration\\n\");\n            return;\n        }\n        if (print_token_amount(amount,\n                               ticker,\n                               decimals,\n                               params-&gt;printable_amount,\n                               sizeof(params-&gt;printable_amount)) != 0) {\n            PRINTF(\"print_amount failed\\n\");\n            return;\n        }\n    }\n\n    PRINTF(\"Amount %s\\n\", params-&gt;printable_amount);\n}\n</code></pre></p>"},{"location":"technical_informations/coin_application_api/ui_bypass/","title":"UI bypass","text":"<p>The goal of the Exchange application is to allow the user to perform a fully trusted SWAP through a single screen UI review.</p> <p>The Exchange application handles the trust checking and the UI, the FROM coin application handles the final payment. This final payment needs to be validated without UI call as long as all conditions are strictly met.</p> <p>Please refer to the sequence diagram if you want to see the process flow in more details.</p> <p>The UI bypass on the coin application need to abide by the following rules:</p> <ul> <li>The bypass is used only when started by Exchange.</li> <li>The bypass is only used for a single type of simple transaction.</li> <li>The bypass is only used if the destination strictly matches.</li> <li>The bypass is only used if the amount strictly matches.</li> <li>The bypass is only used if the fees strictly matches.</li> </ul> <p>If a transaction received in the SWAP context does not match the requirements, it needs to be rejected without UI prompt. The Exchange application will handle the refusal screen display.</p> <p>Here is an example of the high level detection of the UI bypass.</p> <p><code>app-solana/src/handle_sign_message.c</code> <pre><code>void handle_sign_message_ui(volatile unsigned int *flags) {\n    // Display the transaction summary\n    SummaryItemKind_t summary_step_kinds[MAX_TRANSACTION_SUMMARY_ITEMS];\n    size_t num_summary_steps = 0;\n    if (transaction_summary_finalize(summary_step_kinds, &amp;num_summary_steps) == 0) {\n        // If we are in swap context, do not redisplay the message data\n        // Instead, ensure they are identical with what was previously displayed\n        if (G_called_from_swap) {\n            if (G_swap_response_ready) {\n                // Safety against trying to make the app sign multiple TX\n                // This code should never be triggered as the app is supposed to exit after\n                // sending the signed transaction\n                PRINTF(\"Safety against double signing triggered\\n\");\n                os_sched_exit(-1);\n            } else {\n                // We will quit the app after this transaction, whether it succeeds or fails\n                PRINTF(\"Swap response is ready, the app will quit after the next send\\n\");\n                G_swap_response_ready = true;\n            }\n            if (check_swap_validity(summary_step_kinds, num_summary_steps)) {\n                PRINTF(\"Valid swap transaction received, signing and replying it\\n\");\n                sendResponse(set_result_sign_message(), ApduReplySuccess, false);\n            } else {\n                PRINTF(\"Refuse to sign an incorrect Swap transaction\\n\");\n                sendResponse(0, ApduReplySolanaSummaryFinalizeFailed, false);\n            }\n        } else {\n            // We have been started from the dashboard, prompt the UI to the user as usual\n            start_sign_tx_ui(num_summary_steps);\n        }\n    } else {\n        THROW(ApduReplySolanaSummaryFinalizeFailed);\n    }\n\n    *flags |= IO_ASYNCH_REPLY;\n}\n</code></pre></p> <p>The content of the <code>check_swap_validity()</code> function can also be found in the linked file for more information.</p>"},{"location":"walkthrough/","title":"Enabling the SWAP on your application","text":"<p>This guide will help you add the SWAP compatibility to your application.</p> <p>This guide uses a Test Driven approach.</p>"},{"location":"walkthrough/code_the_handlers/","title":"Code the handlers","text":""},{"location":"walkthrough/code_the_handlers/#code-the-handlers-to-make-the-first-tests-pass","title":"Code the handlers to make the first tests pass","text":"<p>The next step is to code the two first handlers to make the tests <code>swap_ui_only</code> and <code>swap_wrong_refund</code> pass with success</p>"},{"location":"walkthrough/code_the_handlers/#test-swap_ui_only","title":"Test <code>swap_ui_only</code>","text":"<p>This test stops before sending the <code>START_SIGNING_TRANSACTION</code> APDU. This means that no coin signature takes place, the only handlers called are <code>swap_handle_check_address()</code> and <code>swap_handle_get_printable_amount()</code>.</p> <p>You can use this test to validate that:</p> <ul> <li><code>swap_handle_check_address()</code> correctly recognizes the <code>valid_destination_1</code> address.</li> <li><code>swap_handle_get_printable_amount()</code> correctly formats the amount on screen.</li> </ul> <p>Don't forget to run ragger with the <code>--golden_run</code> option when creating / updating the snapshots.</p>"},{"location":"walkthrough/code_the_handlers/#test-swap_wrong_refund","title":"Test <code>swap_wrong_refund</code>","text":"<p>This test sends an address that does not belong to the device as refund address.</p> <p>You can use this test to validate that <code>swap_handle_check_address()</code> correctly refuses to recognize the <code>fake_refund</code> address.</p>"},{"location":"walkthrough/code_the_handlers/#code-the-last-handler-and-the-ui-bypass","title":"Code the last handler and the UI bypass","text":"<p>You can now code the <code>swap_copy_transaction_parameters()</code> handler.</p> <p>You can now also code the UI bypass in the final transaction signature.</p> <p>Please refer to the UI bypass documentation carefully.</p> <p>Please refer to the Coin application error codes to know how to handle the refusal of the final transaction.</p> <p>All tests should now pass.</p>"},{"location":"walkthrough/enable_standard_app/","title":"Creating a basic SWAP test for you coin","text":""},{"location":"walkthrough/enable_standard_app/#add-the-cal-data-for-your-application","title":"Add the CAL data for your application","text":"<p>Please find more information about what the CAL is and how it is used in the Crypto Asset List section.</p> <p>Add the coin configuration for your currency in the test/python/apps/cal.py file.</p> <p>Do not use the subconfiguration field for now, you can add it later if you happen to need it, in the meantime the standard configuration will do fine for getting started. </p>"},{"location":"walkthrough/enable_standard_app/#enable-the-exchange-tests-for-your-application","title":"Enable the Exchange tests for your application","text":"<p>Exchange tests are written in a factorized way. The core of the tests is done in the ExchangeTestRunner class.</p> <p>Individual tests import and extend the ExchangeTestRunner class to leverage the test framework written inside. </p> <p>Write a first draft of the Exchange test for you application, you can take the TON test as an example.</p> <p>test/python/test_ton.py</p> <p>The test consists of two parts:</p> <ul> <li>a <code>TonTests</code> class that extends <code>ExchangeTestRunner</code>.</li> <li>a <code>TestsTon</code> class that encompasses all <code>test_ton_*</code> tests that are expanded by its parametrization.</li> </ul> <pre><code>import pytest\nimport os\n\nfrom .apps.ton_application_client.ton_transaction import Transaction, SendMode, CommentPayload, Payload, JettonTransferPayload, NFTTransferPayload, CustomUnsafePayload, JettonBurnPayload, AddWhitelistPayload, SingleNominatorWithdrawPayload, ChangeValidatorPayload, TonstakersDepositPayload, JettonDAOVotePayload, ChangeDNSWalletPayload, ChangeDNSPayload, TokenBridgePaySwapPayload\nfrom .apps.ton_application_client.ton_command_sender import BoilerplateCommandSender, Errors\nfrom .apps.ton_application_client.ton_response_unpacker import unpack_sign_tx_response\nfrom .apps.ton_utils import check_signature_validity\n\n# XXX:\n#   tonsdk seems not te be maintained anymore, python package describe by official TON documentation\n#   is pytoniq-core (offline part) and pytoniq (oneline part).\n#   tonsdk.boc.Cell cannot handle exotic cell but this is required in order to compute jetton wallet address.\nfrom pytoniq_core import Address, Cell, begin_cell\n\nfrom ledger_app_clients.exchange.test_runner import ExchangeTestRunner, ALL_TESTS_EXCEPT_MEMO_THORSWAP_AND_FEES\nfrom .apps.ton import DEVICE_PUBLIC_KEY, Bounceability, WorkchainID, craft_address, SW_SWAP_FAILURE, TON_DERIVATION_PATH\nfrom .apps import cal as cal\n\n\n# ExchangeTestRunner implementation for Ton\nclass TonTests(ExchangeTestRunner):\n    # The coin configuration used for this currency\n    currency_configuration = cal.TON_CURRENCY_CONFIGURATION\n\n    # A valid TON address that will be used as trade partner address in the tests\n    valid_destination_1 = \"EQD0sKn8DbS12U015TWOSpYmyJYYDC_7sxg1upaMxnBvTiX8\"\n    # A different one with the same purpose\n    valid_destination_2 = \"EQANxfGN1EgFPawYB1fhPqebKe1Nb6FIsaiekEecJ6R-3kYF\"\n\n    # The address of the device with the Speculos seed on the derivation path used in\n    # self.currency_configuration\n    valid_refund = \"UQDWey_FGPhd3phmerdVXi-zUIujfyO4-29y_VT1yD0meY1n\"\n\n    # Amounts that will be used by the trade partner in this tests\n    valid_send_amount_1 = 12345670000\n    valid_send_amount_2 = 446739662\n    valid_fees_1 = 100000000\n    valid_fees_2 = 10000123\n\n    # An address that is not the address of the device with the Speculos seed on the derivation\n    # path used in self.currency_configuration.\n    fake_refund = \"EQD0sKn8DbS12U015TWOSpYmyJYYDC_7sxg1upaMxnBvTiX8\"\n    fake_payout = \"EQD0sKn8DbS12U015TWOSpYmyJYYDC_7sxg1upaMxnBvTiX8\"\n\n    # The error code returned by the application when refusing to validate the final transaction.\n    wrong_method_error_code = SW_SWAP_FAILURE\n    wrong_destination_error_code = SW_SWAP_FAILURE\n    wrong_amount_error_code = SW_SWAP_FAILURE\n\n    # The perform_final_tx() function will be called by the ExchangeTestRunner class to finalize a\n    # TON payment if needed by the test.\n    # This function will create a TON payment of 'send_amount' with 'fees' to 'destination'\n    def perform_final_tx(self, destination, send_amount, fees, memo):\n        # Unused memo\n\n        # Use the app interface instead of raw interface\n        client = BoilerplateCommandSender(self.backend)\n\n        # First we need to get the public key of the device in order to build the transaction\n        pubkey = client.get_public_key(path=TON_DERIVATION_PATH).data\n\n        # Create the transaction that will be sent to the device for signing\n        tx = Transaction(Address(destination),\n                         SendMode.PAY_GAS_SEPARATLY,\n                         0,\n                         1686176000,\n                         True,\n                         send_amount)\n        tx_bytes = tx.to_request_bytes()\n\n        # Send the sign device instruction.\n        # As it requires on-screen validation, the function is asynchronous.\n        # It will yield the result when the navigation is done\n        with client.sign_tx(path=TON_DERIVATION_PATH, transaction=tx_bytes):\n            pass\n\n        # The device as yielded the result, parse it and ensure that the signature is correct\n        response = client.get_async_response().data\n        sig, hash_b = unpack_sign_tx_response(response)\n        assert hash_b == tx.transfer_cell().bytes_hash()\n        assert check_signature_validity(pubkey, sig, hash_b)\n\nclass TonUSDTTests(TonTests):\n    jetton_master_address = Address(\"EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs\")\n    code_cell = Cell.one_from_boc(\n        \"b5ee9c72010101010023000842028f452d7a4dfd74066b682365177259ed05734435be76b5fd4bd5d8af2b7c3d68\"\n    )\n\n    currency_configuration = cal.TON_USDT_CURRENCY_CONFIGURATION\n\n    def get_jetton_wallet_address(self, owner: Address) -&gt; Address:\n        data_cell = (\n            begin_cell()\n            .store_uint(0, 4)\n            .store_coins(0)\n            .store_address(owner)\n            .store_address(self.jetton_master_address)\n            .end_cell()\n        )\n        state_init = (\n            begin_cell()\n            .store_uint(0, 2)\n            .store_maybe_ref(self.code_cell)\n            .store_maybe_ref(data_cell)\n            .store_uint(0, 1)\n            .end_cell()\n        )\n        state_init_hex = state_init.hash.hex()\n        return Address(f\"0:{state_init_hex}\")\n\n    def perform_final_tx(self, destination, send_amount, fees, memo):\n        # Use the app interface instead of raw interface\n        client = BoilerplateCommandSender(self.backend)\n        from_address = self.get_jetton_wallet_address(Address(self.valid_refund))\n\n        # First we need to get the public key of the device in order to build the transaction\n        pubkey = client.get_public_key(path=TON_DERIVATION_PATH).data\n\n        payload = JettonTransferPayload(send_amount, Address(destination), jetton_id=0, forward_amount=1)\n\n        # transaction for Jetton transfer are sent to the owned jetton wallet\n        # destination address is serialized in Jetton Transfer Payload\n        tx = Transaction(\n            from_address,\n            SendMode.PAY_GAS_SEPARATLY,\n            seqno=0,\n            timeout=1686176000,\n            bounce=Address(destination).is_bounceable,\n            amount=fees,\n            payload=payload,\n        )\n        tx_bytes = tx.to_request_bytes()\n\n        with client.sign_tx(path=TON_DERIVATION_PATH, transaction=tx_bytes):\n            # As there is no display inside the TON call when using the application through\n            # Exchange, we simply end the asynchronism.\n            pass\n\n        # The device as yielded the result, parse it and ensure that the signature is correct\n        response = client.get_async_response().data\n        sig, hash_b = unpack_sign_tx_response(response)\n        assert hash_b == tx.transfer_cell().bytes_hash()\n        assert check_signature_validity(pubkey, sig, hash_b)\n\n\n# Use a class to reuse the same Speculos instance\nclass TestsTon:\n\n    # Paremetrize the test_ton function with all the ExchangeTestRunner tests to run\n    @pytest.mark.parametrize('test_to_run', ALL_TESTS_EXCEPT_MEMO_THORSWAP_AND_FEES)\n    def test_ton(self, backend, exchange_navigation_helper, test_to_run):\n        if backend.firmware.device == \"nanos\":\n            pytest.skip(\"Ton swap is not supported on NanoS device\")\n        TonTests(backend, exchange_navigation_helper).run_test(test_to_run)\n\n    @pytest.mark.parametrize('test_to_run', ALL_TESTS_EXCEPT_MEMO_THORSWAP_AND_FEES)\n    def test_ton_usdt(self, backend, exchange_navigation_helper, test_to_run):\n        if backend.firmware.device == \"nanos\":\n            pytest.skip(\"Ton swap is not supported on NanoS device\")\n        TonUSDTTests(backend, exchange_navigation_helper).run_test(test_to_run)\n</code></pre> <p>Create a <code>test_&lt;appname&gt;.py</code> that follows the same structure. You can leave the function <code>perform_final_tx()</code> empty for now if you want.</p> <p>You can validate this step by running the <code>swap_ui_only()</code> test for your coin, it should pass as we coded empty yesmen shells for our tests.</p>"},{"location":"walkthrough/enable_the_swap_compilation/","title":"First compilation with the standard SWAP","text":""},{"location":"walkthrough/enable_the_swap_compilation/#enable-the-swap-feature","title":"Enable the SWAP feature","text":"<p>In the Makefile, set the variable <code>ENABLE_SWAP = 1</code> of the standard Makefile as in the example below.</p> <p><code>app-solana/Makefile</code> <pre><code>########################################\n# Application communication interfaces #\n########################################\nENABLE_BLUETOOTH = 1\n\n########################################\n#         NBGL custom features         #\n########################################\nENABLE_NBGL_QRCODE = 1\n\n########################################\n#            Swap features             #\n########################################\nENABLE_SWAP = 1\n</code></pre></p> <p>Then compile your application, you should encounter the following error:</p> <pre><code>ld.lld: error: undefined symbol: swap_copy_transaction_parameters\n&gt;&gt;&gt; referenced by main.c\n&gt;&gt;&gt;               build/nanox/obj/sdk/lib_standard_app/main.o:(library_app_main)\n\nld.lld: error: undefined symbol: swap_handle_get_printable_amount\n&gt;&gt;&gt; referenced by main.c\n&gt;&gt;&gt;               build/nanox/obj/sdk/lib_standard_app/main.o:(library_app_main)\n\nld.lld: error: undefined symbol: swap_handle_check_address\n&gt;&gt;&gt; referenced by main.c\n&gt;&gt;&gt;               build/nanox/obj/sdk/lib_standard_app/main.o:(library_app_main)\n</code></pre> <p>They are caused by the missing handles definition. To know more about what the handles do, you can refer to the handle documentation.</p>"},{"location":"walkthrough/enable_the_swap_compilation/#fix-compilation-errors","title":"Fix compilation errors","text":"<p>For now we will declare the handles in the most basic possible way.</p> <p>Add the following files to your application, it is recommended to follow the following file structure:</p> <pre><code>$&gt; ls ../app-solana/src/swap/\nhandle_check_address.c  handle_get_printable_amount.c  handle_swap_sign_transaction.c\nhandle_check_address.h  handle_get_printable_amount.h  handle_swap_sign_transaction.h\n</code></pre> <p>Add the functions declarations in the <code>.h</code> files and the functions definitions in the <code>.c</code> files. Define empty functions for now. <pre><code>#include \"os.h\"\n#include \"swap_lib_calls.h\"\n\nvoid swap_handle_check_address(check_address_parameters_t *params) {\n    // Accept all addresses\n    params-&gt;result = 1;\n}\n\nvoid swap_handle_get_printable_amount(get_printable_amount_parameters_t* params) {\n    // Format all amounts as 10\n    strcpy(params-&gt;printable_amount, \"10\");\n}\n\nbool swap_copy_transaction_parameters(create_transaction_parameters_t* params) {\n    // Do nothing successfully\n    return true;\n}\n</code></pre></p>"},{"location":"walkthrough/enable_the_swap_compilation/#copy-your-compiled-binary","title":"Copy your compiled binary","text":"<p>Copy the binary compiled above into the Exchange library directory <code>app-exchange/test/python/lib_binaries/</code> under the name <code>&lt;VARIANT_VALUES&gt;_device.elf</code>, with <code>VARIANT_VALUES</code> from your Makefile.</p> <p>Add your application to the test/python/conftest.py file.</p> <pre><code>def pytest_configure(config):\n    current_setup = config.getoption(\"--setup\")\n    # We don't need any lib dependency for the prod_build test\n    if current_setup == \"default\":\n        # List of sideloaded applications under the format &lt;VARIANT_VALUES&gt;:&lt;APPNAME&gt;\n        configuration.OPTIONAL.SIDELOADED_APPS = {\n            \"APTOS\": \"Aptos\",\n            \"bitcoin\": \"Bitcoin\",\n            \"bitcoin_legacy\": \"Bitcoin Legacy\",\n            \"ethereum\": \"Ethereum\",\n            \"ethereum_classic\": \"Ethereum Classic\",\n            \"tezos\": \"Tezos Wallet\",\n            \"xrp\": \"XRP\",\n            \"litecoin\": \"Litecoin\",\n            \"stellar\": \"Stellar\",\n            \"solana\": \"Solana\",\n            \"DOT\": \"Polkadot\",\n            \"tron\": \"Tron\",\n            \"ton\": \"TON\",\n            \"ATOM\": \"Cosmos\",\n            \"cardano\": \"Cardano ADA\",\n            \"near\": \"NEAR\",\n            \"sui\": \"Sui\",\n            \"boilerplate\": \"Boilerplate\",\n            \"kaspa\": \"Kaspa\",\n            \"hedera\": \"Hedera\"\n        }\n\n        configuration.OPTIONAL.SIDELOADED_APPS_DIR = \"test/python/lib_binaries/\"\n</code></pre> <p>You can run an unrelated Exchange test as done in the Run a simple test section to validate the sideloading of your application. </p>"},{"location":"walkthrough/prerequisite/","title":"Prerequisite","text":"<p>Before proceeding with the SWAP integration, ensure that your application:</p> <ul> <li>Uses the Standard Makefile.</li> <li>Follows the Standard application format.</li> </ul> <p>Although this step may seem unrelated to the SWAP feature, it significantly simplifies the integration process to the point that no support is provided if you do without.</p> <p>If you need to port your application to the Standard format, you should use the app-boilerplate as example.</p>"},{"location":"walkthrough/run_first_test/","title":"Running an existing SWAP test","text":"<p>This page provides all the essential setup details to help you get started on enabling the SWAP feature in your application.</p>"},{"location":"walkthrough/run_first_test/#running-a-first-exchange-test","title":"Running a first Exchange test","text":""},{"location":"walkthrough/run_first_test/#clone-the-exchange-application","title":"Clone the Exchange application","text":"<p>Clone the Exchange application.</p> <p>This application is required for testing your coin application but does not need any modifications in the C code.</p> <p>The Exchange test framework is part of this repository, meaning that all swap-related tests for your coin application must be added inside the Exchange repository. This structure will change in the future.</p>"},{"location":"walkthrough/run_first_test/#install-python-dependencies","title":"Install Python dependencies","text":"<p>In the Exchange application repository, run the following command to install the required dependencies: <pre><code>pip install -r test/python/requirements.txt\n</code></pre></p>"},{"location":"walkthrough/run_first_test/#compile-the-exchange-application","title":"Compile the Exchange application","text":"<p>If using the Ledger VSCode extension, compile the Exchange application using the use_case dbg_use_test_keys. Otherwise, open the <code>ledger_app.toml</code> file, check what flags are associated with the aforementioned use case and build Exchange with this flags set. </p>"},{"location":"walkthrough/run_first_test/#compile-the-coin-applications","title":"Compile the coin applications","text":"<p>The Exchange test framework requires all swappable coin libraries to be compiled with the correct flags.</p> <p>Compiling them manually is a long and error-prone process, so instead, grab a CI artifact output:</p> <ol> <li> <p>Go to the official test CI</p> </li> <li> <p>Download the artifact <code>libraries_binaries.zip</code> from the latest successful run targeting the develop branch.</p> </li> <li> <p>Extract the archive in <code>test/python/lib_binaries/</code></p> </li> </ol> <p>Example result <pre><code>$&gt; ls test/python/lib_binaries/\nAPTOS_flex.elf           bitcoin_legacy_nanos.elf     ethereum_classic_stax.elf  solana_nanos.elf    tezos_stax.elf\nAPTOS_nanos.elf          bitcoin_legacy_nanos2.elf    ethereum_flex.elf          solana_nanos2.elf   ton_flex.elf\nAPTOS_nanos2.elf         bitcoin_legacy_nanox.elf     ethereum_nanos.elf         solana_nanox.elf    ton_nanos.elf\nAPTOS_nanox.elf          bitcoin_legacy_stax.elf      ethereum_nanos2.elf        solana_stax.elf     ton_nanos2.elf\nAPTOS_stax.elf           bitcoin_nanos.elf            ethereum_nanox.elf         stellar_flex.elf    ton_nanox.elf\nATOM_flex.elf            bitcoin_nanos2.elf           ethereum_stax.elf          stellar_nanos.elf   ton_stax.elf\nATOM_nanos.elf           bitcoin_nanox.elf            libraries_binaries.zip     stellar_nanos2.elf  tron_flex.elf\nATOM_nanos2.elf          bitcoin_stax.elf             litecoin_flex.elf          stellar_nanox.elf   tron_nanos.elf\nATOM_nanox.elf           cardano_flex.elf             litecoin_nanos.elf         stellar_stax.elf    tron_nanos2.elf\nATOM_stax.elf            cardano_nanos.elf            litecoin_nanos2.elf        sui_flex.elf        tron_nanox.elf\nDOT_flex.elf             cardano_nanos2.elf           litecoin_nanox.elf         sui_nanos2.elf      tron_stax.elf\nDOT_nanos.elf            cardano_nanox.elf            litecoin_stax.elf          sui_nanox.elf       xrp_flex.elf\nDOT_nanos2.elf           cardano_stax.elf             near_flex.elf              sui_stax.elf        xrp_nanos.elf\nDOT_nanox.elf            ethereum_classic_flex.elf    near_nanos2.elf            tezos_flex.elf      xrp_nanos2.elf\nDOT_stax.elf             ethereum_classic_nanos.elf   near_nanox.elf             tezos_nanos.elf     xrp_nanox.elf\nbitcoin_flex.elf         ethereum_classic_nanos2.elf  near_stax.elf              tezos_nanos2.elf    xrp_stax.elf\nbitcoin_legacy_flex.elf  ethereum_classic_nanox.elf   solana_flex.elf            tezos_nanox.elf\n</code></pre></p>"},{"location":"walkthrough/run_first_test/#run-a-simple-test","title":"Run a simple test","text":"<p>To see all available tests: <pre><code>pytest -v --tb=short test/python/ --device all --collect-only\n</code></pre></p> <p>To list only Solana tests for Stax: <pre><code>pytest -v --tb=short test/python/ --device stax --collect-only -k solana\n</code></pre></p> <p>To run a specific Solana test for Stax: <pre><code>pytest -v --tb=short test/python/ --device stax -k 'test_solana[stax-swap_valid_1]' -s\n</code></pre></p> <p>You should remember how to run a single, this will be useful later on.</p>"},{"location":"walkthrough/run_first_test/#next-steps","title":"Next steps","text":"<p>Now you know how to setup and run the Exchange tests, you'll be able to add the tests for your own application and run them as you develop the SWAP feature in your application.</p>"}]}